-- Generated by Ora2Pg, the Oracle database Schema converter, version 17.4
-- Copyright 2000-2016 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=sgd-nex2-db.stanford.edu;sid=SGD

SET client_encoding TO 'UTF8';

\set ON_ERROR_STOP ON


DROP TRIGGER IF EXISTS dbentity_aiudr ON nex.dbentity CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_dbentity_aiudr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'INSERT') THEN

       IF NOT EXISTS (SELECT display_name
                      FROM nex.sgdid
		      WHERE display_name = NEW.SGDID) THEN

            PERFORM nex.insertsgdid(NEW.sgdid, 'SGD'::text, NEW.subclass, 'Primary'::text, NEW.created_by);

       END IF;
       RETURN NEW;
       
  ELSIF (TG_OP = 'UPDATE') THEN

    IF (OLD.format_name != NEW.format_name) THEN
        PERFORM nex.insertupdatelog('DBENTITY'::text, 'FORMAT_NAME'::text, OLD.dbentity_id, OLD.format_name, NEW.format_name, USER);
    END IF;

    IF (OLD.display_name != NEW.display_name) THEN
        PERFORM nex.insertupdatelog('DBENTITY'::text, 'DISPLAY_NAME'::text, OLD.dbentity_id, OLD.display_name, NEW.display_name, USER);
    END IF;

    IF (OLD.obj_url != NEW.obj_url) THEN
        PERFORM nex.insertupdatelog('DBENTITY'::text, 'OBJ_URL'::text, OLD.dbentity_id, OLD.obj_url, NEW.obj_url, USER);
    END IF;

    IF (OLD.source_id != NEW.source_id) THEN
        PERFORM nex.insertupdatelog('DBENTITY'::text, 'SOURCE_ID'::text, OLD.dbentity_id, OLD.source_id::text, NEW.source_id::text, USER);
    END IF;

    IF (((OLD.bud_id IS NULL) AND (NEW.bud_id IS NOT NULL)) OR ((OLD.bud_id IS NOT NULL) AND (NEW.bud_id IS NULL)) OR (OLD.bud_id != NEW.bud_id)) THEN
        PERFORM nex.insertupdatelog('DBENTITY'::text, 'BUD_ID'::text, OLD.dbentity_id, OLD.bud_id::text, NEW.bud_id::text, USER);
    END IF;

    IF (OLD.subclass != NEW.subclass) THEN
       PERFORM nex.insertupdatelog('DBENTITY'::text, 'SUBCLASS'::text, OLD.dbentity_id, OLD.subclass, NEW.subclass, USER);
    END IF;

    IF (OLD.dbentity_status != NEW.dbentity_status) THEN
        PERFORM nex.insertupdatelog('DBENTITY'::text, 'DBENTITY_STATUS'::text, OLD.dbentity_id, OLD.dbentity_status, NEW.dbentity_status, USER);
        PERFORM nex.insertlocuschange(OLD.dbentity_id, 'SGD'::text, 'Status'::text, OLD.dbentity_status, NEW.dbentity_status, USER);
    END IF;

    RETURN NEW;
    
  ELSIF (TG_OP = 'DELETE') THEN

    UPDATE nex.sgdid SET sgdid_status = 'Deleted'
    WHERE display_name = OLD.sgdid;

    v_row := OLD.dbentity_id || '[:]' || OLD.format_name || '[:]' ||
             OLD.display_name || '[:]' || OLD.obj_url || '[:]' ||
             OLD.source_id || '[:]' || coalesce(OLD.bud_id,0) || '[:]' ||
             OLD.sgdid || '[:]' || OLD.subclass || '[:]' ||
             OLD.dbentity_status || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

     PERFORM nex.insertdeletelog('DBENTITY'::text, OLD.dbentity_id, v_row, USER);

     RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER dbentity_aiudr
AFTER INSERT OR UPDATE OR DELETE ON nex.dbentity FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_dbentity_aiudr();

DROP TRIGGER IF EXISTS dbentity_biudr ON nex.dbentity CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_dbentity_biudr() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

    IF (NEW.sgdid IS NULL) THEN
        NEW.sgdid := nex.makesgdid();
    ELSE
        NEW.sgdid := upper(NEW.sgdid);
        PERFORM nex.checksgdid(NEW.sgdid);
    END IF;

   IF (NEW.subclass = 'REFERENCE') THEN
       NEW.format_name := NEW.sgdid;
   END IF;

   IF (NEW.obj_url IS NULL) THEN
        NEW.obj_url := CONCAT('/'||lower(NEW.subclass)||'/', NEW.sgdid);
   END IF;

    IF (NEW.subclass = 'LOCUS') THEN
        IF (NEW.dbentity_status = 'Archived') THEN
            RAISE EXCEPTION 'Allowable values are Active, Merged, Deleted.';
        END IF;
    ELSIF (NEW.subclass = 'FILE') THEN
        IF (NEW.dbentity_status = 'Merged') OR (NEW.dbentity_status = 'Deleted') THEN
            RAISE EXCEPTION 'Allowable values are Active or Archived.';
        END IF;
    ELSIF (NEW.subclass = 'STRAIN') OR (NEW.subclass = 'REFERENCE') OR (NEW.subclass = 'PATHWAY') THEN
        IF (NEW.dbentity_status != 'Active') THEN
            RAISE EXCEPTION 'Only allowable value is Active.';
      	END IF;
    END IF;

    NEW.created_by := upper(NEW.created_by);
    PERFORM nex.checkuser(NEW.created_by);

    RETURN NEW;
       
  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.dbentity_id != OLD.dbentity_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.sgdid != OLD.sgdid) THEN
        RAISE EXCEPTION 'This column cannot be updated.';
    END IF;

   IF (NEW.subclass = 'REFERENCE') THEN
       IF (NEW.format_name := OLD.format_name) THEN
          RAISE EXCEPTION 'This column cannot be updated.';
   END IF;

    IF (NEW.subclass != OLD.subclass) THEN
        RAISE EXCEPTION 'This column cannot be updated.';
    END IF;

    IF (NEW.obj_url != OLD.obj_url) THEN
        RAISE EXCEPTION 'This column cannot be updated.';
    END IF;

    IF (NEW.subclass = 'LOCUS') THEN
        IF (NEW.dbentity_status = 'Archived') THEN
              RAISE EXCEPTION 'Allowable values are Active, Merged, Deleted.';
        END IF;
    ELSIF (NEW.subclass = 'FILE') THEN
	    IF (NEW.dbentity_status = 'Merged') OR (NEW.dbentity_status = 'Deleted') THEN
            RAISE EXCEPTION 'Allowable values are Active or Archived.';
	    END IF;
    ELSIF (NEW.subclass = 'STRAIN') OR (NEW.subclass = 'REFERENCE') OR (NEW.subclass = 'PATHWAY') THEN
	    IF (NEW.dbentity_status != 'Active') THEN
            RAISE EXCEPTION 'Only allowable value is Active.';
        END IF;
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

     RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    IF ((OLD.subclass = 'LOCUS') OR (OLD.subclass = 'STRAIN')) THEN
       RAISE EXCEPTION 'This dbentity subclass can not be deleted.';
    END	IF;

    RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER dbentity_biudr
BEFORE INSERT OR UPDATE OR DELETE ON nex.dbentity FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_dbentity_biudr();

DROP TRIGGER IF EXISTS locusdbentity_audr ON nex.locusdbentity CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_locusdbentity_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

    IF (OLD.systematic_name != NEW.systematic_name) THEN
        PERFORM nex.insertupdatelog('LOCUSDBENTITY'::text, 'SYSTEMATIC_NAME'::text, OLD.dbentity_id, OLD.systematic_name, NEW.systematic_name, USER);
    END IF;

    IF (((OLD.gene_name IS NULL) AND (NEW.gene_name IS NOT NULL)) OR ((OLD.gene_name IS NOT NULL) AND (NEW.gene_name IS NULL)) OR (OLD.gene_name != NEW.gene_name)) THEN
        PERFORM nex.insertupdatelog('LOCUSDBENTITY'::text, 'GENE_NAME'::text, OLD.dbentity_id, OLD.gene_name, NEW.gene_name, USER);
        PERFORM nex.insertlocuschange(OLD.dbentity_id, 'SGD'::text, 'Gene name'::text, OLD.gene_name, NEW.gene_name, USER);
    END IF;

    IF (((OLD.qualifier IS NULL) AND (NEW.qualifier IS NOT NULL)) OR ((OLD.qualifier IS NOT NULL) AND (NEW.qualifier IS NULL)) OR (OLD.qualifier != NEW.qualifier)) THEN
        PERFORM nex.insertupdatelog('LOCUSDBENTITY'::text, 'QUALIFIER'::text, OLD.dbentity_id, OLD.qualifier, NEW.qualifier, USER);
	PERFORM nex.insertlocuschange(OLD.dbentity_id, 'SGD'::text, 'Qualifier'::text, OLD.qualifier, NEW.qualifier, USER);
    END IF;

    IF (((OLD.genetic_position IS NULL) AND (NEW.genetic_position IS NOT NULL)) OR ((OLD.genetic_position IS NOT NULL) AND (NEW.genetic_position IS NULL)) OR (OLD.genetic_position != NEW.genetic_position)) THEN
        PERFORM nex.insertupdatelog('LOCUSDBENTITY'::text, 'GENETIC_POSITION'::text, OLD.dbentity_id, OLD.genetic_position::text, NEW.genetic_position::text, USER);
    END IF;

    IF (((OLD.name_description IS NULL) AND (NEW.name_description IS NOT NULL)) OR ((OLD.name_description IS NOT NULL) AND (NEW.name_description IS NULL)) OR (OLD.name_description != NEW.name_description)) THEN
        PERFORM nex.insertupdatelog('LOCUSDBENTITY'::text, 'NAME_DESCRIPTION'::text, OLD.dbentity_id, OLD.name_description, NEW.name_description, USER);
    END IF;

    IF (((OLD.headline IS NULL) AND (NEW.headline IS NOT NULL)) OR ((OLD.headline IS NOT NULL) AND (NEW.headline IS NULL)) OR (OLD.headline != NEW.headline)) THEN
        PERFORM nex.insertupdatelog('LOCUSDBENTITY'::text, 'HEADLINE'::text, OLD.dbentity_id, OLD.headline, NEW.headline, USER);
    END IF;

    IF (((OLD.description IS NULL) AND (NEW.description IS NOT NULL)) OR ((OLD.description IS NOT NULL) AND (NEW.description IS NULL)) OR (OLD.description != NEW.description)) THEN
        PERFORM nex.insertupdatelog('LOCUSDBENTITY'::text, 'DESCRIPTION'::text, OLD.dbentity_id, OLD.description, NEW.description, USER);
    END IF;

    IF (OLD.has_summary != NEW.has_summary) THEN
        PERFORM nex.insertupdatelog('LOCUSDBENTITY'::text, 'HAS_SUMMARY'::text, OLD.dbentity_id, OLD.has_summary::text, NEW.has_summary::text, USER);
    END IF;

    IF (OLD.has_sequence != NEW.has_sequence) THEN
        PERFORM nex.insertupdatelog('LOCUSDBENTITY'::text, 'HAS_SEQUENCE'::text, OLD.dbentity_id, OLD.has_sequence::text, NEW.has_sequence::text, USER);
    END IF;

    IF (OLD.has_history != NEW.has_history) THEN
        PERFORM nex.insertupdatelog('LOCUSDBENTITY'::text, 'HAS_HISTORY'::text, OLD.dbentity_id, OLD.has_history::text, NEW.has_history::text, USER);
    END IF;

    IF (OLD.has_literature != NEW.has_literature) THEN
        PERFORM nex.insertupdatelog('LOCUSDBENTITY'::text, 'HAS_LITERATURE'::text, OLD.dbentity_id, OLD.has_literature::text, NEW.has_literature::text, USER);
    END IF;

    IF (OLD.has_go != NEW.has_go) THEN
        PERFORM nex.insertupdatelog('LOCUSDBENTITY'::text, 'HAS_GO'::text, OLD.dbentity_id, OLD.has_go::text, NEW.has_go::text, USER);
    END IF;

    IF (OLD.has_phenotype != NEW.has_phenotype) THEN
        PERFORM nex.insertupdatelog('LOCUSDBENTITY'::text, 'HAS_PHENOTYPE'::text, OLD.dbentity_id, OLD.has_phenotype::text, NEW.has_phenotype::text, USER);
    END IF;

    IF (OLD.has_interaction != NEW.has_interaction) THEN
        PERFORM nex.insertupdatelog('LOCUSDBENTITY'::text, 'HAS_INTERACTION'::text, OLD.dbentity_id, OLD.has_interaction::text, NEW.has_interaction::text, USER);
    END IF;

    IF (OLD.has_expression != NEW.has_expression) THEN
        PERFORM nex.insertupdatelog('LOCUSDBENTITY'::text, 'HAS_EXPRESSION'::text, OLD.dbentity_id, OLD.has_expression::text, NEW.has_expression::text, USER);
    END IF;

    IF (OLD.has_regulation != NEW.has_regulation) THEN
        PERFORM nex.insertupdatelog('LOCUSDBENTITY'::text, 'HAS_REGULATION'::text, OLD.dbentity_id, OLD.has_regulation::text, NEW.has_regulation::text, USER);
    END IF;

    IF (OLD.has_protein != NEW.has_protein) THEN
        PERFORM nex.insertupdatelog('LOCUSDBENTITY'::text, 'HAS_PROTEIN'::text, OLD.dbentity_id, OLD.has_protein::text, NEW.has_protein::text, USER);
    END IF;

    IF (OLD.has_sequence_section != NEW.has_sequence_section) THEN
        PERFORM nex.insertupdatelog('LOCUSDBENTITY'::text, 'HAS_SEQUENCE_SECTION'::text, OLD.dbentity_id, OLD.has_sequence_section::text, NEW.has_sequence_section::text, USER);
    END IF;

    IF (OLD.not_in_s288c != NEW.not_in_s288c) THEN
        PERFORM nex.insertupdatelog('LOCUSDBENTITY'::text, 'NOT_IN_S288C'::text, OLD.dbentity_id, OLD.not_in_s288c::text, NEW.not_in_s288c::text, USER);
    END IF;

    RETURN NEW;
    
  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.dbentity_id || '[:]' || OLD.systematic_name || '[:]' ||
             coalesce(OLD.gene_name,'') || '[:]' || coalesce(OLD.qualifier,'') || '[:]' ||
             coalesce(OLD.genetic_position,0) || '[:]' || coalesce(OLD.name_description,'') || '[:]' ||
             coalesce(OLD.headline,'') || '[:]' || coalesce(OLD.description,'') || '[:]' ||
             OLD.has_summary || '[:]' || OLD.has_sequence || '[:]' ||
             OLD.has_history || '[:]' || OLD.has_literature || '[:]' ||
             OLD.has_go || '[:]' || OLD.has_phenotype || '[:]' ||
             OLD.has_interaction || '[:]' || OLD.has_expression || '[:]' ||
             OLD.has_regulation || '[:]' || OLD.has_protein || '[:]' ||
             OLD.has_sequence_section || '[:]' || OLD.not_in_s288c;

            PERFORM nex.insertdeletelog('LOCUSDBENTITY'::text, OLD.dbentity_id, v_row, USER);

    RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER locusdbentity_audr
AFTER UPDATE OR DELETE ON nex.locusdbentity FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_locusdbentity_audr();

DROP TRIGGER IF EXISTS locusdbentity_biur ON nex.locusdbentity CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_locusdbentity_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

    IF (NEW.gene_name IS NOT NULL) THEN
        NEW.gene_name := upper(NEW.gene_name);
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.dbentity_id != OLD.dbentity_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.gene_name IS NOT NULL) THEN
        NEW.gene_name := upper(NEW.gene_name);
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER locusdbentity_biur
BEFORE INSERT OR UPDATE ON nex.locusdbentity FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_locusdbentity_biur();

DROP TRIGGER IF EXISTS locusalias_audr ON nex.locus_alias CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_locusalias_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

     IF (OLD.display_name != NEW.display_name) THEN
        PERFORM nex.insertupdatelog('LOCUS_ALIAS'::text, 'DISPLAY_NAME'::text, OLD.alias_id, OLD.display_name, NEW.display_name, USER);
    END IF;

    IF (((OLD.obj_url IS NULL) AND (NEW.obj_url IS NOT NULL)) OR ((OLD.obj_url IS NOT NULL) AND (NEW.obj_url IS NULL)) OR (OLD.obj_url != NEW.obj_url)) THEN
        PERFORM nex.insertupdatelog('LOCUS_ALIAS'::text, 'OBJ_URL'::text, OLD.alias_id, OLD.obj_url, NEW.obj_url, USER);
    END IF;

     IF (OLD.source_id != NEW.source_id) THEN
        PERFORM nex.insertupdatelog('LOCUS_ALIAS'::text, 'SOURCE_ID'::text, OLD.alias_id, OLD.source_id::text, NEW.source_id::text, USER);
    END IF;

    IF (((OLD.bud_id IS NULL) AND (NEW.bud_id IS NOT NULL)) OR ((OLD.bud_id IS NOT NULL) AND (NEW.bud_id IS NULL)) OR (OLD.bud_id != NEW.bud_id)) THEN
        PERFORM nex.insertupdatelog('LOCUS_ALIAS'::text, 'BUD_ID'::text, OLD.alias_id, OLD.bud_id::text, NEW.bud_id::text, USER);
    END IF;

    IF (OLD.locus_id != NEW.locus_id) THEN
        PERFORM nex.insertupdatelog('LOCUS_ALIAS'::text, 'LOCUS_ID'::text, OLD.alias_id, OLD.locus_id::text, NEW.locus_id::text, USER);
    END IF;

    IF (OLD.has_external_id_section != NEW.has_external_id_section) THEN
        PERFORM nex.insertupdatelog('LOCUS_ALIAS'::text, 'HAS_EXTERNAL_ID_SECTION'::text, OLD.alias_id, OLD.has_external_id_section::text, NEW.has_external_id_section::text, USER);
    END IF;

    IF (OLD.alias_type != NEW.alias_type) THEN
        PERFORM nex.insertupdatelog('LOCUS_ALIAS'::text, 'ALIAS_TYPE'::text, OLD.alias_id, OLD.alias_type, NEW.alias_type, USER);
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.alias_id || '[:]' || OLD.display_name || '[:]' ||
             coalesce(OLD.obj_url,'') || '[:]' || OLD.source_id || '[:]' ||
	     coalesce(OLD.bud_id,0) || '[:]' || OLD.locus_id || '[:]' ||
	     OLD.has_external_id_section || '[:]' || OLD.alias_type || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

          PERFORM nex.insertdeletelog('LOCUS_ALIAS'::text, OLD.alias_id, v_row, USER);

    RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER locusalias_audr
AFTER UPDATE OR DELETE ON nex.locus_alias FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_locusalias_audr();

DROP TRIGGER IF EXISTS locusalias_biur ON nex.locus_alias CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_locusalias_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

    NEW.created_by := upper(NEW.created_by);
    PERFORM nex.checkuser(NEW.created_by);

    RETURN NEW;

  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.alias_id != OLD.alias_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER locusalias_biur
BEFORE INSERT OR UPDATE ON nex.locus_alias FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_locusalias_biur();

DROP TRIGGER IF EXISTS locusrelation_audr ON nex.locus_relation CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_locusrelation_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

     IF (OLD.source_id != NEW.source_id) THEN
        PERFORM nex.insertupdatelog('LOCUS_RELATION'::text, 'SOURCE_ID'::text, OLD.relation_id, OLD.source_id::text, NEW.source_id::text, USER);
    END IF;

    IF (((OLD.bud_id IS NULL) AND (NEW.bud_id IS NOT NULL)) OR ((OLD.bud_id IS NOT NULL) AND (NEW.bud_id IS NULL)) OR (OLD.bud_id != NEW.bud_id)) THEN
        PERFORM nex.insertupdatelog('LOCUS_RELATION'::text, 'BUD_ID'::text, OLD.relation_id, OLD.bud_id::text, NEW.bud_id::text, USER);
    END IF;

    IF (OLD.parent_id != NEW.parent_id) THEN
        PERFORM nex.insertupdatelog('LOCUS_RELATION'::text, 'PARENT_ID'::text, OLD.relation_id, OLD.parent_id::text, NEW.parent_id::text, USER);
    END IF;

     IF (OLD.child_id != NEW.child_id) THEN
        PERFORM nex.insertupdatelog('LOCUS_RELATION'::text, 'CHILD_ID'::text, OLD.relation_id, OLD.child_id::text, NEW.child_id::text, USER);
    END IF;

    IF (OLD.ro_id != NEW.ro_id) THEN
        PERFORM nex.insertupdatelog('LOCUS_RELATION'::text, 'RO_ID'::text, OLD.relation_id, OLD.ro_id::text, NEW.ro_id::text, USER);
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.relation_id || '[:]' || OLD.source_id || '[:]' ||
             coalesce(OLD.bud_id,0) || '[:]' || OLD.parent_id || '[:]' ||
             OLD.child_id || '[:]' || OLD.ro_id || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

         PERFORM nex.insertdeletelog('LOCUS_RELATION'::text, OLD.relation_id, v_row, USER);

     RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER locusrelation_audr
AFTER UPDATE OR DELETE ON nex.locus_relation FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_locusrelation_audr();

DROP TRIGGER IF EXISTS locusrelation_biur ON nex.locus_relation CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_locusrelation_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := upper(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;

  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.relation_id != OLD.relation_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

   RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER locusrelation_biur
BEFORE INSERT OR UPDATE ON nex.locus_relation FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_locusrelation_biur();

DROP TRIGGER IF EXISTS locusurl_audr ON nex.locus_url CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_locusurl_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

    IF (OLD.display_name != NEW.display_name) THEN
        PERFORM nex.insertupdatelog('LOCUS_URL'::text, 'DISPLAY_NAME'::text, OLD.url_id, OLD.display_name, NEW.display_name, USER);
    END IF;

    IF (OLD.obj_url != NEW.obj_url) THEN
        PERFORM nex.insertupdatelog('LOCUS_URL'::text, 'OBJ_URL'::text, OLD.url_id, OLD.obj_url, NEW.obj_url, USER);
    END IF;

     IF (OLD.source_id != NEW.source_id) THEN
        PERFORM nex.insertupdatelog('LOCUS_URL'::text, 'SOURCE_ID'::text, OLD.url_id, OLD.source_id::text, NEW.source_id::text, USER);
    END IF;

    IF (((OLD.bud_id IS NULL) AND (NEW.bud_id IS NOT NULL)) OR ((OLD.bud_id IS NOT NULL) AND (NEW.bud_id IS NULL)) OR (OLD.bud_id != NEW.bud_id)) THEN
        PERFORM nex.insertupdatelog('LOCUS_URL'::text, 'BUD_ID'::text, OLD.url_id, OLD.bud_id::text, NEW.bud_id::text, USER);
    END IF;

    IF (OLD.locus_id != NEW.locus_id) THEN
        PERFORM nex.insertupdatelog('LOCUS_URL'::text, 'LOCUS_ID'::text, OLD.url_id, OLD.locus_id::text, NEW.locus_id::text, USER);
    END IF;

    IF (OLD.url_type != NEW.url_type) THEN
        PERFORM nex.insertupdatelog('LOCUS_URL'::text, 'URL_TYPE'::text, OLD.url_id, OLD.url_type, NEW.url_type, USER);
    END IF;

    IF (OLD.placement != NEW.placement) THEN
        PERFORM nex.insertupdatelog('LOCUS_URL'::text, 'PLACEMENT'::text, OLD.url_id, OLD.placement, NEW.placement, USER);
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.url_id || '[:]' || OLD.display_name || '[:]' ||
             OLD.obj_url || '[:]' || OLD.source_id || '[:]' ||
	         coalesce(OLD.bud_id,0) || '[:]' || OLD.locus_id || '[:]' ||
	         OLD.url_type || '[:]' || OLD.placement || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

         PERFORM nex.insertdeletelog('LOCUS_URL'::text, OLD.url_id, v_row, USER);

    RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER locusurl_audr
AFTER UPDATE OR DELETE ON nex.locus_url FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_locusurl_audr();

DROP TRIGGER IF EXISTS locusurl_biur ON nex.locus_url CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_locusurl_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := upper(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;
       
  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.url_id != OLD.url_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER locusurl_biur
BEFORE INSERT OR UPDATE ON nex.locus_url FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_locusurl_biur();

DROP TRIGGER IF EXISTS locussummary_audr ON nex.locussummary CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_locussummary_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

     IF (OLD.source_id != NEW.source_id) THEN
        PERFORM nex.insertupdatelog('LOCUSSUMMARY'::text, 'SOURCE_ID'::text, OLD.summary_id, OLD.source_id::text, NEW.source_id::text, USER);
    END IF;

    IF (((OLD.bud_id IS NULL) AND (NEW.bud_id IS NOT NULL)) OR ((OLD.bud_id IS NOT NULL) AND (NEW.bud_id IS NULL)) OR (OLD.bud_id != NEW.bud_id)) THEN
        PERFORM nex.insertupdatelog('LOCUSSUMMARY'::text, 'BUD_ID'::text, OLD.summary_id, OLD.bud_id::text, NEW.bud_id::text, USER);
    END IF;

    IF (OLD.locus_id != NEW.locus_id) THEN
        PERFORM nex.insertupdatelog('LOCUSSUMMARY'::text, 'LOCUS_ID'::text, OLD.summary_id, OLD.locus_id::text, NEW.locus_id::text, USER);
    END IF;

    IF (OLD.summary_type != NEW.summary_type) THEN
        PERFORM nex.insertupdatelog('LOCUSSUMMARY'::text, 'SUMMARY_TYPE'::text, OLD.summary_id, OLD.summary_type, NEW.summary_type, USER);
    END IF;

    IF (OLD.summary_order != NEW.summary_order) THEN
        PERFORM nex.insertupdatelog('LOCUSSUMMARY'::text, 'SUMMARY_ORDER'::text, OLD.summary_id, OLD.summary_order::text, NEW.summary_order::text, USER);
    END IF;

    IF (OLD.text != NEW.text) THEN
        PERFORM nex.insertupdatelog('LOCUSSUMMARY'::text, 'TEXT'::text, OLD.summary_id, OLD.text, NEW.text, USER);
    END IF;

    IF (OLD.html != NEW.html) THEN
        PERFORM nex.insertupdatelog('LOCUSSUMMARY'::text, 'HTML'::text, OLD.summary_id, OLD.html, NEW.html, USER);
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.summary_id || '[:]' || OLD.source_id || '[:]' ||
             coalesce(OLD.bud_id,0) || '[:]' || OLD.locus_id || '[:]' ||
             OLD.summary_type || '[:]' || OLD.summary_order || '[:]' ||
             OLD.text || '[:]' || OLD.html || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

             PERFORM nex.insertdeletelog('LOCUSSUMMARY'::text, OLD.summary_id, v_row, USER);

     RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER locussummary_audr
AFTER UPDATE OR DELETE ON nex.locussummary FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_locussummary_audr();

DROP TRIGGER IF EXISTS locussummary_biur ON nex.locussummary CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_locussummary_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := upper(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;
       
  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.summary_id != OLD.summary_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER locussummary_biur
BEFORE INSERT OR UPDATE ON nex.locussummary FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_locussummary_biur();

DROP TRIGGER IF EXISTS locussummaryreference_audr ON nex.locussummary_reference CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_locussummaryreference_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

    IF (OLD.summary_id != NEW.summary_id) THEN
        PERFORM nex.insertupdatelog('SUMMARY_REFERENCE'::text, 'SUMMARY_ID'::text, OLD.summary_reference_id, OLD.summary_id::text, NEW.summary_id::text, USER);
    END IF;

     IF (OLD.reference_id != NEW.reference_id) THEN
        PERFORM nex.insertupdatelog('SUMMARY_REFERENCE'::text, 'REFERENCE_ID'::text, OLD.summary_reference_id, OLD.reference_id::text, NEW.reference_id::text, USER);
    END IF;

     IF (OLD.reference_order != NEW.reference_order) THEN
        PERFORM nex.insertupdatelog('SUMMARY_REFERENCE'::text, 'REFERENCE_ORDER'::text, OLD.summary_reference_id, OLD.reference_order::text, NEW.reference_order::text, USER);
    END IF;

     IF (OLD.source_id != NEW.source_id) THEN
        PERFORM nex.insertupdatelog('SUMMARY_REFERENCE'::text, 'SOURCE_ID'::text, OLD.summary_reference_id, OLD.source_id::text, NEW.source_id::text, USER);
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.summary_reference_id || '[:]' || OLD.summary_id || '[:]' ||
             OLD.reference_id || '[:]' || OLD.reference_order || '[:]' ||
             OLD.source_id || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

             PERFORM nex.insertdeletelog('SUMMARY_REFERENCE'::text, OLD.summary_reference_id, v_row, USER);

     RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER locussummaryreference_audr
AFTER UPDATE OR DELETE ON nex.locussummary_reference FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_locussummaryreference_audr();

DROP TRIGGER IF EXISTS locussummaryreference_biur ON nex.locussummary_reference CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_locussummaryreference_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := upper(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;

  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.summary_reference_id != OLD.summary_reference_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER locussummaryreference_biur
BEFORE INSERT OR UPDATE ON nex.locussummary_reference FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_locussummaryreference_biur();


DROP TRIGGER IF EXISTS straindbentity_audr ON nex.straindbentity CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_straindbentity_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

    IF (OLD.taxonomy_id != NEW.taxonomy_id) THEN
        PERFORM nex.insertupdatelog('STRAINDBENTITY'::text, 'TAXONOMY_ID'::text, OLD.dbentity_id, OLD.taxonomy_id::text, NEW.taxonomy_id::text, USER);
    END IF;

    IF (OLD.strain_type != NEW.strain_type) THEN
        PERFORM nex.insertupdatelog('STRAINDBENTITY'::text, 'STRAIN_TYPE'::text, OLD.dbentity_id, OLD.strain_type, NEW.strain_type, USER);
    END IF;

    IF (OLD.headline != NEW.headline) THEN
        PERFORM nex.insertupdatelog('STRAINDBENTITY'::text, 'HEADLINE'::text, OLD.dbentity_id, OLD.headline, NEW.headline, USER);
    END IF;

    IF (((OLD.genotype IS NULL) AND (NEW.genotype IS NOT NULL)) OR ((OLD.genotype IS NOT NULL) AND (NEW.genotype IS NULL)) OR (OLD.genotype != NEW.genotype)) THEN
        PERFORM nex.insertupdatelog('STRAINDBENTITY'::text, 'GENOTYPE'::text, OLD.dbentity_id, OLD.genotype, NEW.genotype, USER);
    END IF;

    IF (((OLD.genbank_id IS NULL) AND (NEW.genbank_id IS NOT NULL)) OR ((OLD.genbank_id IS NOT NULL) AND (NEW.genbank_id IS NULL)) OR (OLD.genbank_id != NEW.genbank_id)) THEN
        PERFORM nex.insertupdatelog('STRAINDBENTITY'::text, 'GENBANK_ID'::text, OLD.dbentity_id, OLD.genbank_id, NEW.genbank_id, USER);
    END IF;

    IF (((OLD.assembly_size IS NULL) AND (NEW.assembly_size IS NOT NULL)) OR ((OLD.assembly_size IS NOT NULL) AND (NEW.assembly_size IS NULL)) OR (OLD.assembly_size != NEW.assembly_size)) THEN
        PERFORM nex.insertupdatelog('STRAINDBENTITY'::text, 'ASSEMBLY_SIZE'::text, OLD.dbentity_id, OLD.assembly_size::text, NEW.assembly_size::text, USER);
    END IF;

    IF (((OLD.fold_coverage IS NULL) AND (NEW.fold_coverage IS NOT NULL)) OR ((OLD.fold_coverage IS NOT NULL) AND (NEW.fold_coverage IS NULL)) OR (OLD.fold_coverage != NEW.fold_coverage)) THEN
        PERFORM nex.insertupdatelog('STRAINDBENTITY'::text, 'FOLD_COVERAGE'::text, OLD.dbentity_id, OLD.fold_coverage::text, NEW.fold_coverage::text, USER);
    END IF;

    IF (((OLD.scaffold_number IS NULL) AND (NEW.scaffold_number IS NOT NULL)) OR ((OLD.scaffold_number IS NOT NULL) AND (NEW.scaffold_number IS NULL)) OR (OLD.scaffold_number != NEW.scaffold_number)) THEN
        PERFORM nex.insertupdatelog('STRAINDBENTITY'::text, 'SCAFFOLD_NUMBER'::text, OLD.dbentity_id, OLD.scaffold_number::text, NEW.scaffold_number::text, USER);
    END IF;

    IF (((OLD.longest_scaffold IS NULL) AND (NEW.longest_scaffold IS NOT NULL)) OR ((OLD.longest_scaffold IS NOT NULL) AND (NEW.longest_scaffold IS NULL)) OR (OLD.longest_scaffold != NEW.longest_scaffold)) THEN
        PERFORM nex.insertupdatelog('STRAINDBENTITY'::text, 'LONGEST_SCAFFOLD'::text, OLD.dbentity_id, OLD.longest_scaffold::text, NEW.longest_scaffold::text, USER);
    END IF;

    IF (((OLD.scaffold_nfifty IS NULL) AND (NEW.scaffold_nfifty IS NOT NULL)) OR ((OLD.scaffold_nfifty IS NOT NULL) AND (NEW.scaffold_nfifty IS NULL)) OR (OLD.scaffold_nfifty != NEW.scaffold_nfifty)) THEN
        PERFORM nex.insertupdatelog('STRAINDBENTITY'::text, 'SCAFFOLD_NFIFTY'::text, OLD.dbentity_id, OLD.scaffold_nfifty::text, NEW.scaffold_nfifty::text, USER);
    END IF;

    IF (((OLD.feature_count IS NULL) AND (NEW.feature_count IS NOT NULL)) OR ((OLD.feature_count IS NOT NULL) AND (NEW.feature_count IS NULL)) OR (OLD.feature_count != NEW.feature_count)) THEN
        PERFORM nex.insertupdatelog('STRAINDBENTITY'::text, 'FEATURE_COUNT'::text, OLD.dbentity_id, OLD.feature_count::text, NEW.feature_count::text, USER);
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.dbentity_id || '[:]' || OLD.taxonomy_id || '[:]' || 
             OLD.strain_type || '[:]' || OLD.headline || '[:]' ||
             coalesce(OLD.genotype,'') || '[:]' || coalesce(OLD.genbank_id,'') || '[:]' ||
             coalesce(OLD.assembly_size,0) || '[:]' || coalesce(OLD.fold_coverage,0) || '[:]' ||
             coalesce(OLD.scaffold_number,0) || '[:]' || coalesce(OLD.longest_scaffold,0) || '[:]' ||
             coalesce(OLD.scaffold_nfifty,0) || '[:]' || coalesce(OLD.feature_count,0);

            PERFORM nex.insertdeletelog('STRAINDBENTITY'::text, OLD.dbentity_id, v_row, USER);

     RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER straindbentity_audr
AFTER UPDATE OR DELETE ON nex.straindbentity FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_straindbentity_audr();

DROP TRIGGER IF EXISTS straindbentity_bur ON nex.straindbentity CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_straindbentity_bur() RETURNS trigger AS $BODY$
BEGIN

    IF (NEW.dbentity_id != OLD.dbentity_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

RETURN NEW;
END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER straindbentity_bur
BEFORE UPDATE ON nex.straindbentity FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_straindbentity_bur();

DROP TRIGGER IF EXISTS strainurl_audr ON nex.strain_url CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_strainurl_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

     IF (OLD.display_name != NEW.display_name) THEN
        PERFORM nex.insertupdatelog('STRAIN_URL'::text, 'DISPLAY_NAME'::text, OLD.url_id, OLD.display_name, NEW.display_name, USER);
    END IF;

    IF (OLD.obj_url != NEW.obj_url) THEN
        PERFORM nex.insertupdatelog('STRAIN_URL'::text, 'OBJ_URL'::text, OLD.url_id, OLD.obj_url, NEW.obj_url, USER);
    END IF;

     IF (OLD.source_id != NEW.source_id) THEN
        PERFORM nex.insertupdatelog('STRAIN_URL'::text, 'SOURCE_ID'::text, OLD.url_id, OLD.source_id::text, NEW.source_id::text, USER);
    END IF;

    IF (OLD.strain_id != NEW.strain_id) THEN
        PERFORM nex.insertupdatelog('STRAIN_URL'::text, 'STRAIN_ID'::text, OLD.url_id, OLD.strain_id::text, NEW.strain_id::text, USER);
    END IF;

    IF (OLD.url_type != NEW.url_type) THEN
        PERFORM nex.insertupdatelog('STRAIN_URL'::text, 'URL_TYPE'::text, OLD.url_id, OLD.url_type, NEW.url_type, USER);
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.url_id || '[:]' || OLD.display_name || '[:]' ||
             OLD.obj_url || '[:]' || OLD.source_id || '[:]' || 
             OLD.strain_id || '[:]' || OLD.url_type || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

          PERFORM nex.insertdeletelog('STRAIN_URL'::text, OLD.url_id, v_row, USER);

    RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER strainurl_audr
AFTER UPDATE OR DELETE ON nex.strain_url FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_strainurl_audr();

DROP TRIGGER IF EXISTS strainurl_biur ON nex.strain_url CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_strainurl_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := upper(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;
       
  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.url_id != OLD.url_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER strainurl_biur
BEFORE INSERT OR UPDATE ON nex.strain_url FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_strainurl_biur();

DROP TRIGGER IF EXISTS strainsummary_audr ON nex.strainsummary CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_strainsummary_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

     IF (OLD.source_id != NEW.source_id) THEN
        PERFORM nex.insertupdatelog('STRAINSUMMARY'::text, 'SOURCE_ID'::text, OLD.summary_id, OLD.source_id::text, NEW.source_id::text, USER);
    END IF;

    IF (OLD.strain_id != NEW.strain_id) THEN
        PERFORM nex.insertupdatelog('STRAINSUMMARY'::text, 'STRAIN_ID'::text, OLD.summary_id, OLD.strain_id::text, NEW.strain_id::text, USER);
    END IF;

    IF (OLD.summary_type != NEW.summary_type) THEN
        PERFORM nex.insertupdatelog('STRAINSUMMARY'::text, 'SUMMARY_TYPE'::text, OLD.summary_id, OLD.summary_type, NEW.summary_type, USER);
    END IF;

    IF (OLD.text != NEW.text) THEN
        PERFORM nex.insertupdatelog('STRAINSUMMARY'::text, 'TEXT'::text, OLD.summary_id, OLD.text, NEW.text, USER);
    END IF;

    IF (OLD.html != NEW.html) THEN
        PERFORM nex.insertupdatelog('STRAINSUMMARY'::text, 'HTML'::text, OLD.summary_id, OLD.html, NEW.html, USER);
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.summary_id || '[:]' || OLD.source_id || '[:]' ||
             OLD.strain_id || '[:]' || OLD.summary_type || '[:]' ||
             OLD.text || '[:]' || OLD.html || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

           PERFORM nex.insertdeletelog('STRAINSUMMARY'::text, OLD.summary_id, v_row, USER);

     RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER strainsummary_audr
AFTER UPDATE OR DELETE ON nex.strainsummary FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_strainsummary_audr();

DROP TRIGGER IF EXISTS strainsummary_biur ON nex.strainsummary CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_strainsummary_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := upper(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;

  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.summary_id != OLD.summary_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN  NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER strainsummary_biur
BEFORE INSERT OR UPDATE ON nex.strainsummary FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_strainsummary_biur();


DROP TRIGGER IF EXISTS strainsummaryreference_audr ON nex.strainsummary_reference CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_strainsummaryreference_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

    IF (OLD.summary_id != NEW.summary_id)    THEN
        PERFORM nex.insertupdatelog('SUMMARY_REFERENCE'::text, 'SUMMARY_ID'::text, OLD.summary_reference_id, OLD.summary_id::text, NEW.summary_id::text, USER);
    END IF;

     IF (OLD.reference_id != NEW.reference_id) THEN
        PERFORM nex.insertupdatelog('SUMMARY_REFERENCE'::text, 'REFERENCE_ID'::text, OLD.summary_reference_id, OLD.reference_id::text, NEW.reference_id::text, USER);
    END IF;

     IF (OLD.reference_order != NEW.reference_order) THEN
        PERFORM nex.insertupdatelog('SUMMARY_REFERENCE'::text, 'REFERENCE_ORDER'::text, OLD.summary_reference_id, OLD.reference_order::text, NEW.reference_order::text, USER);
    END IF;

     IF (OLD.source_id != NEW.source_id) THEN
        PERFORM nex.insertupdatelog('SUMMARY_REFERENCE'::text, 'SOURCE_ID'::text, OLD.summary_reference_id, OLD.source_id::text, NEW.source_id::text, USER);
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.summary_reference_id || '[:]' || OLD.summary_id || '[:]' ||
             OLD.reference_id || '[:]' || OLD.reference_order || '[:]' ||
             OLD.source_id || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

             PERFORM nex.insertdeletelog('SUMMARY_REFERENCE'::text, OLD.summary_reference_id, v_row, USER);

    RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER strainsummaryreference_audr
AFTER UPDATE OR DELETE ON nex.strainsummary_reference FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_strainsummaryreference_audr();

DROP TRIGGER IF EXISTS strainsummaryreference_biur ON nex.strainsummary_reference CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_strainsummaryreference_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := upper(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;

  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.summary_reference_id != OLD.summary_reference_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER strainsummaryreference_biur
BEFORE INSERT OR UPDATE ON nex.strainsummary_reference FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_strainsummaryreference_biur();


DROP TRIGGER IF EXISTS pathwaydbentity_audr ON nex.pathwaydbentity CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_pathwaydbentity_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
   v_sgdid   	nex.dbentity.sgdid%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

    IF (((OLD.biocyc_id IS NULL) AND (NEW.biocyc_id IS NOT NULL)) OR ((OLD.biocyc_id IS NOT NULL) AND (NEW.biocyc_id IS NULL)) OR (OLD.biocyc_id != NEW.biocyc_id)) THEN
        PERFORM nex.insertupdatelog('PATHWAYDBENTITY'::text, 'BIOCYC_ID'::text, OLD.dbentity_id, OLD.biocyc_id, NEW.biocyc_id, USER);
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

        SELECT sgdid INTO v_sgdid
        FROM nex.dbentity
        WHERE dbentity_id = OLD.dbentity_id;
	
        UPDATE nex.sgdid SET sgdid_status = 'Deleted'
	    WHERE display_name = v_sgdid;
	       
        v_row := OLD.dbentity_id || '[:]' || coalesce(OLD.biocyc_id,'');

        PERFORM nex.insertdeletelog('PATHWAYDBENTITY'::text, OLD.dbentity_id, v_row, USER);

    RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER pathwaydbentity_audr
AFTER UPDATE OR DELETE ON nex.pathwaydbentity FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_pathwaydbentity_audr();

DROP TRIGGER IF EXISTS pathwaydbentity_bur ON nex.pathwaydbentity CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_pathwaydbentity_bur() RETURNS trigger AS $BODY$
BEGIN

    IF (NEW.dbentity_id != OLD.dbentity_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

RETURN NEW;
END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER pathwaydbentity_bur
BEFORE UPDATE ON nex.pathwaydbentity FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_pathwaydbentity_bur();

DROP TRIGGER IF EXISTS pathwayalias_audr ON nex.pathway_alias CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_pathwayalias_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

    IF (OLD.display_name != NEW.display_name) THEN
        PERFORM nex.insertupdatelog('PATHWAY_ALIAS'::text, 'DISPLAY_NAME'::text, OLD.alias_id, OLD.display_name, NEW.display_name, USER);
    END IF;

     IF (OLD.source_id != NEW.source_id) THEN
        PERFORM nex.insertupdatelog('PATHWAY_ALIAS'::text, 'SOURCE_ID'::text, OLD.alias_id, OLD.source_id::text, NEW.source_id::text, USER);
    END IF;

    IF (OLD.pathway_id != NEW.pathway_id) THEN
        PERFORM nex.insertupdatelog('PATHWAY_ALIAS'::text, 'PATHWAY_ID'::text, OLD.alias_id, OLD.pathway_id::text, NEW.pathway_id::text, USER);
    END IF;

    IF (OLD.alias_type != NEW.alias_type) THEN
        PERFORM nex.insertupdatelog('PATHWAY_ALIAS'::text, 'ALIAS_TYPE'::text, OLD.alias_id, OLD.alias_type, NEW.alias_type, USER);
    END IF;

    RETURN NEW;
  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.alias_id || '[:]' || OLD.display_name || '[:]' || 
             OLD.source_id || '[:]' || 
             OLD.pathway_id || '[:]' || OLD.alias_type || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

           PERFORM nex.insertdeletelog('PATHWAY_ALIAS'::text, OLD.alias_id, v_row, USER);

     RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER pathwayalias_audr
AFTER UPDATE OR DELETE ON nex.pathway_alias FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_pathwayalias_audr();

DROP TRIGGER IF EXISTS pathwayalias_biur ON nex.pathway_alias CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_pathwayalias_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := upper(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;

  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.alias_id != OLD.alias_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER pathwayalias_biur
BEFORE INSERT OR UPDATE ON nex.pathway_alias FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_pathwayalias_biur();

DROP TRIGGER IF EXISTS pathwayurl_audr ON nex.pathway_url CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_pathwayurl_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

     IF (OLD.display_name != NEW.display_name) THEN
        PERFORM nex.insertupdatelog('PATHWAY_URL'::text, 'DISPLAY_NAME'::text, OLD.url_id, OLD.display_name, NEW.display_name, USER);
    END IF;

    IF (OLD.obj_url != NEW.obj_url) THEN
        PERFORM nex.insertupdatelog('PATHWAY_URL'::text, 'OBJ_URL'::text, OLD.url_id, OLD.obj_url, NEW.obj_url, USER);
    END IF;

     IF (OLD.source_id != NEW.source_id) THEN
        PERFORM nex.insertupdatelog('PATHWAY_URL'::text, 'SOURCE_ID'::text, OLD.url_id, OLD.source_id::text, NEW.source_id::text, USER);
    END IF;

    IF (OLD.pathway_id != NEW.pathway_id) THEN
        PERFORM nex.insertupdatelog('PATHWAY_URL'::text, 'PATHWAY_ID'::text, OLD.url_id, OLD.pathway_id::text, NEW.pathway_id::text, USER);
    END IF;

    IF (OLD.url_type != NEW.url_type) THEN
        PERFORM nex.insertupdatelog('PATHWAY_URL'::text, 'URL_TYPE'::text, OLD.url_id, OLD.url_type, NEW.url_type, USER);
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.url_id || '[:]' || OLD.display_name || '[:]' ||
             OLD.obj_url || '[:]' || OLD.source_id || '[:]' || 
             OLD.pathway_id || '[:]' || OLD.url_type || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

            PERFORM nex.insertdeletelog('PATHWAY_URL'::text, OLD.url_id, v_row, USER);

     RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER pathwayurl_audr
AFTER UPDATE OR DELETE ON nex.pathway_url FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_pathwayurl_audr();

DROP TRIGGER IF EXISTS pathwayurl_biur ON nex.pathway_url CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_pathwayurl_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := upper(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;

  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.url_id != OLD.url_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER pathwayurl_biur
BEFORE INSERT OR UPDATE ON nex.pathway_url FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_pathwayurl_biur();

DROP TRIGGER IF EXISTS pathwaysummary_audr ON nex.pathwaysummary CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_pathwaysummary_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

     IF (OLD.source_id != NEW.source_id) THEN
        PERFORM nex.insertupdatelog('PATHWAYSUMMARY'::text, 'SOURCE_ID'::text, OLD.summary_id, OLD.source_id::text, NEW.source_id::text, USER);
    END IF;

    IF (OLD.pathway_id != NEW.pathway_id) THEN
        PERFORM nex.insertupdatelog('PATHWAYSUMMARY'::text, 'PATHWAY_ID'::text, OLD.summary_id, OLD.pathway_id::text, NEW.pathway_id::text, USER);
    END IF;

    IF (OLD.summary_type != NEW.summary_type) THEN
        PERFORM nex.insertupdatelog('PATHWAYSUMMARY'::text, 'SUMMARY_TYPE'::text, OLD.summary_id, OLD.summary_type, NEW.summary_type, USER);
    END IF;

    IF (OLD.text != NEW.text) THEN
        PERFORM nex.insertupdatelog('PATHWAYSUMMARY'::text, 'TEXT'::text, OLD.summary_id, OLD.text, NEW.text, USER);
    END IF;

    IF (OLD.html != NEW.html) THEN
        PERFORM nex.insertupdatelog('PATHWAYSUMMARY'::text, 'HTML'::text, OLD.summary_id, OLD.html, NEW.html, USER);
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.summary_id || '[:]' || OLD.source_id || '[:]' ||
             OLD.pathway_id || '[:]' || OLD.summary_type || '[:]' ||
             OLD.text || '[:]' || OLD.html || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

            PERFORM nex.insertdeletelog('PATHWAYSUMMARY'::text, OLD.summary_id, v_row, USER);

     RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER pathwaysummary_audr
AFTER UPDATE OR DELETE ON nex.pathwaysummary FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_pathwaysummary_audr();

DROP TRIGGER IF EXISTS pathwaysummary_biur ON nex.pathwaysummary CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_pathwaysummary_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := upper(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;
       
  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.summary_id != OLD.summary_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER pathwaysummary_biur
BEFORE INSERT OR UPDATE ON nex.pathwaysummary FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_pathwaysummary_biur();

DROP TRIGGER IF EXISTS pathwaysummaryreference_audr ON nex.pathwaysummary_reference CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_pathwaysummaryreference_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

    IF (OLD.summary_id != NEW.summary_id) THEN
        PERFORM nex.insertupdatelog('SUMMARY_REFERENCE'::text, 'SUMMARY_ID'::text, OLD.summary_reference_id, OLD.summary_id::text, NEW.summary_id::text, USER);
    END IF;

     IF (OLD.reference_id != NEW.reference_id) THEN
        PERFORM nex.insertupdatelog('SUMMARY_REFERENCE'::text, 'REFERENCE_ID'::text, OLD.summary_reference_id, OLD.reference_id::text, NEW.reference_id::text, USER);
    END IF;

     IF (OLD.reference_order != NEW.reference_order) THEN
        PERFORM nex.insertupdatelog('SUMMARY_REFERENCE'::text, 'REFERENCE_ORDER'::text, OLD.summary_reference_id, OLD.reference_order::text, NEW.reference_order::text, USER);
    END IF;

     IF (OLD.source_id != NEW.source_id) THEN
        PERFORM nex.insertupdatelog('SUMMARY_REFERENCE'::text, 'SOURCE_ID'::text, OLD.summary_reference_id, OLD.source_id::text, NEW.source_id::text, USER);
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.summary_reference_id || '[:]' || OLD.summary_id || '[:]' ||
             OLD.reference_id || '[:]' || OLD.reference_order || '[:]' ||
             OLD.source_id || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

            PERFORM nex.insertdeletelog('SUMMARY_REFERENCE'::text, OLD.summary_reference_id, v_row, USER);

     RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER pathwaysummaryreference_audr
AFTER UPDATE OR DELETE ON nex.pathwaysummary_reference FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_pathwaysummaryreference_audr();

DROP TRIGGER IF EXISTS pathwaysummaryreference_biur ON nex.pathwaysummary_reference CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_pathwaysummaryreference_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := upper(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;

  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.summary_reference_id != OLD.summary_reference_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER pathwaysummaryreference_biur
BEFORE INSERT OR UPDATE ON nex.pathwaysummary_reference FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_pathwaysummaryreference_biur();


DROP TRIGGER IF EXISTS filepath_audr ON nex.filepath CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_filepath_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

     IF (OLD.source_id != NEW.source_id) THEN
        PERFORM nex.insertupdatelog('FILEPATH'::text, 'SOURCE_ID'::text, OLD.filepath_id, OLD.source_id::text, NEW.source_id::text, USER);
    END IF;

    IF (OLD.filepath != NEW.filepath) THEN
        PERFORM nex.insertupdatelog('FILEPATH'::text, 'FILEPATH'::text, OLD.filepath_id, OLD.filepath, NEW.filepath, USER);
    END IF;

    RETURN NEW;
    
  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.filepath_id || '[:]' || OLD.source_id || '[:]' ||
	         OLD.filepath || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

            PERFORM nex.insertdeletelog('FILEPATH'::text, OLD.filepath_id, v_row, USER);

     RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER filepath_audr
AFTER UPDATE OR DELETE ON nex.filepath FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_filepath_audr();

DROP TRIGGER IF EXISTS filepath_biur ON nex.filepath CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_filepath_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := upper(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;

  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.filepath_id != OLD.filepath_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER filepath_biur
BEFORE INSERT OR UPDATE ON nex.filepath FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_filepath_biur();

DROP TRIGGER IF EXISTS filedbentity_audr ON nex.filedbentity CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_filedbentity_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
    v_sgdid     nex.dbentity.sgdid%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

    IF (OLD.topic_id != NEW.topic_id) THEN
        PERFORM nex.insertupdatelog('FILEDBENTITY'::text, 'TOPIC_ID'::text, OLD.dbentity_id, OLD.topic_id::text, NEW.topic_id::text, USER);
    END IF;

    IF (OLD.data_id != NEW.data_id) THEN
        PERFORM nex.insertupdatelog('FILEDBENTITY'::text, 'DATA_ID'::text, OLD.dbentity_id, OLD.data_id::text, NEW.data_id::text, USER);
    END IF;

    IF (OLD.format_id != NEW.format_id) THEN
        PERFORM nex.insertupdatelog('FILEDBENTITY'::text, 'FORMAT_ID'::text, OLD.dbentity_id, OLD.format_id::text, NEW.format_id::text, USER);
    END IF;

    IF (OLD.file_extension != NEW.file_extension) THEN
        PERFORM nex.insertupdatelog('FILEDBENTITY'::text, 'FILE_EXTENSION'::text, OLD.dbentity_id, OLD.file_extension, NEW.file_extension, USER);
    END IF;

    IF (OLD.file_date != NEW.file_date) THEN
        PERFORM nex.insertupdatelog('FILEDBENTITY'::text, 'FILE_DATE'::text, OLD.dbentity_id, OLD.file_date::text, NEW.file_date::text, USER);
    END IF;

    IF (OLD.is_public != NEW.is_public) THEN
        PERFORM nex.insertupdatelog('FILEDBENTITY'::text, 'IS_PUBLIC'::text, OLD.dbentity_id, OLD.is_public::text, NEW.is_public::text, USER);
    END IF;

    IF (OLD.is_in_spell != NEW.is_in_spell) THEN
        PERFORM nex.insertupdatelog('FILEDBENTITY'::text, 'IS_IN_SPELL'::text, OLD.dbentity_id, OLD.is_in_spell::text, NEW.is_in_spell::text, USER);
    END IF;

    IF (OLD.is_in_browser != NEW.is_in_browser) THEN
        PERFORM nex.insertupdatelog('FILEDBENTITY'::text, 'IS_IN_BROWSER'::text, OLD.dbentity_id, OLD.is_in_browser::text, NEW.is_in_browser::text, USER);
    END IF;

     IF (((OLD.md5sum IS NULL) AND (NEW.md5sum IS NOT NULL)) OR ((OLD.md5sum IS NOT NULL) AND (NEW.md5sum IS NULL)) OR (OLD.md5sum != NEW.md5sum)) THEN
        PERFORM nex.insertupdatelog('FILEDBENTITY'::text, 'MD5SUM'::text, OLD.dbentity_id, OLD.md5sum, NEW.md5sum, USER);
    END IF;

     IF (((OLD.s3_url IS NULL) AND (NEW.s3_url IS NOT NULL)) OR ((OLD.s3_url IS NOT NULL) AND (NEW.s3_url IS NULL)) OR (OLD.s3_url != NEW.s3_url)) THEN
        PERFORM nex.insertupdatelog('FILEDBENTITY'::text, 'S3_URL'::text, OLD.dbentity_id, OLD.s3_url, NEW.s3_url, USER);
    END IF;

     IF (((OLD.filepath_id IS NULL) AND (NEW.filepath_id IS NOT NULL)) OR ((OLD.filepath_id IS NOT NULL) AND (NEW.filepath_id IS NULL)) OR (OLD.filepath_id != NEW.filepath_id)) THEN
        PERFORM nex.insertupdatelog('FILEDBENTITY'::text, 'FILEPATH_ID'::text, OLD.dbentity_id, OLD.filepath_id::text, NEW.filepath_id::text, USER);
    END IF;

     IF (((OLD.previous_file_name IS NULL) AND (NEW.previous_file_name IS NOT NULL)) OR ((OLD.previous_file_name IS NOT NULL) AND (NEW.previous_file_name IS NULL)) OR (OLD.previous_file_name != NEW.previous_file_name)) THEN
        PERFORM nex.insertupdatelog('FILEDBENTITY'::text, 'PREVIOUS_FILE_NAME'::text, OLD.dbentity_id, OLD.previous_file_name, NEW.previous_file_name, USER);
    END IF;

     IF (((OLD.readme_file_id IS NULL) AND (NEW.readme_file_id IS NOT NULL)) OR ((OLD.readme_file_id IS NOT NULL) AND (NEW.readme_file_id IS NULL)) OR (OLD.readme_file_id != NEW.readme_file_id)) THEN
        PERFORM nex.insertupdatelog('FILEDBENTITY'::text, 'README_FILE_ID'::text, OLD.dbentity_id, OLD.readme_file_id::text, NEW.readme_file_id::text, USER);
    END IF;

     IF (((OLD.description IS NULL) AND (NEW.description IS NOT NULL)) OR ((OLD.description IS NOT NULL) AND (NEW.description IS NULL)) OR (OLD.description != NEW.description)) THEN
        PERFORM nex.insertupdatelog('FILEDBENTITY'::text, 'DESCRIPTION'::text, OLD.dbentity_id, OLD.description, NEW.description, USER);
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

        SELECT sgdid INTO v_sgdid
	FROM nex.dbentity
	WHERE dbentity_id = OLD.dbentity_id;

    UPDATE nex.sgdid SET sgdid_status = 'Deleted'
    WHERE display_name = v_sgdid;
	       
    v_row := OLD.dbentity_id || '[:]' || OLD.topic_id || '[:]' ||
             OLD.data_id || '[:]' || OLD.format_id || '[:]' ||
             OLD.file_extension || '[:]' || OLD.file_date || '[:]' ||
             OLD.is_public || '[:]' || OLD.is_in_spell || '[:]' ||
             OLD.is_in_browser || '[:]' || OLD.md5sum || '[:]' ||
             OLD.filepath_id || '[:]' || OLD.readme_file_id || '[:]' ||
             OLD.previous_file_name || '[:]' || OLD.s3_url || '[:]' ||
             OLD.description;

             PERFORM nex.insertdeletelog('FILEDBENTITY'::text, OLD.dbentity_id, v_row, USER);

     RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER filedbentity_audr
AFTER UPDATE OR DELETE ON nex.filedbentity FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_filedbentity_audr();

DROP TRIGGER IF EXISTS filedbentity_bur ON nex.filedbentity CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_filedbentity_bur() RETURNS trigger AS $BODY$
BEGIN

  	IF (NEW.dbentity_id != OLD.dbentity_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

RETURN NEW;
END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER filedbentity_bur
BEFORE UPDATE ON nex.filedbentity FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_filedbentity_bur();

DROP TRIGGER IF EXISTS filekeyword_audr ON nex.file_keyword CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_filekeyword_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

    IF (OLD.file_id != NEW.file_id) THEN
        PERFORM nex.insertupdatelog('FILE_KEYWORD'::text, 'FILE_ID'::text, OLD.file_keyword_id, OLD.file_id::text, NEW.file_id::text, USER);
    END IF;

     IF (OLD.keyword_id != NEW.keyword_id) THEN
        PERFORM nex.insertupdatelog('FILE_KEYWORD'::text, 'KEYWORD_ID'::text, OLD.file_keyword_id, OLD.keyword_id::text, NEW.keyword_id::text, USER);
    END IF;

     IF (OLD.source_id != NEW.source_id) THEN
        PERFORM nex.insertupdatelog('FILE_KEYWORD'::text, 'SOURCE_ID'::text, OLD.file_keyword_id, OLD.source_id::text, NEW.source_id::text, USER);
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.file_keyword_id || '[:]' || OLD.file_id || '[:]' ||
             OLD.keyword_id || '[:]' || OLD.source_id || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

         PERFORM nex.insertdeletelog('FILE_KEYWORD'::text, OLD.file_keyword_id, v_row, USER);

     RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER filekeyword_audr
AFTER UPDATE OR DELETE ON nex.file_keyword FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_filekeyword_audr();

DROP TRIGGER IF EXISTS filekeyword_biur ON nex.file_keyword CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_filekeyword_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := upper(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;

  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.file_keyword_id != OLD.file_keyword_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER filekeyword_biur
BEFORE INSERT OR UPDATE ON nex.file_keyword FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_filekeyword_biur();


DROP TRIGGER IF EXISTS book_audr ON nex.book CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_book_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

    IF (OLD.format_name != NEW.format_name) THEN
        PERFORM nex.insertupdatelog('BOOK'::text, 'FORMAT_NAME'::text, OLD.book_id, OLD.format_name, NEW.format_name, USER);
    END IF;

     IF (OLD.display_name != NEW.display_name) THEN
        PERFORM nex.insertupdatelog('BOOK'::text, 'DISPLAY_NAME'::text, OLD.book_id, OLD.display_name, NEW.display_name, USER);
    END IF;

    IF (OLD.obj_url != NEW.obj_url) THEN
        PERFORM nex.insertupdatelog('BOOK'::text, 'OBJ_URL'::text, OLD.book_id, OLD.obj_url, NEW.obj_url, USER);
    END IF;

     IF (OLD.source_id != NEW.source_id) THEN
        PERFORM nex.insertupdatelog('BOOK'::text, 'SOURCE_ID'::text, OLD.book_id, OLD.source_id::text, NEW.source_id::text, USER);
    END IF;

    IF (((OLD.bud_id IS NULL) AND (NEW.bud_id IS NOT NULL)) OR ((OLD.bud_id IS NOT NULL) AND (NEW.bud_id IS NULL)) OR (OLD.bud_id != NEW.bud_id)) THEN
        PERFORM nex.insertupdatelog('BOOK'::text, 'BUD_ID'::text, OLD.book_id, OLD.bud_id::text, NEW.bud_id::text, USER);
    END IF;

    IF (OLD.title != NEW.title) THEN
        PERFORM nex.insertupdatelog('BOOK'::text, 'TITLE'::text, OLD.book_id, OLD.title, NEW.title, USER);
    END IF;

    IF (((OLD.volume_title IS NULL) AND (NEW.volume_title IS NOT NULL)) OR ((OLD.volume_title IS NOT NULL) AND (NEW.volume_title IS NULL)) OR (OLD.volume_title != NEW.volume_title)) THEN
        PERFORM nex.insertupdatelog('BOOK'::text, 'VOLUME_TITLE'::text, OLD.book_id, OLD.volume_title, NEW.volume_title, USER);
    END IF;

    IF (((OLD.isbn IS NULL) AND (NEW.isbn IS NOT NULL)) OR ((OLD.isbn IS NOT NULL) AND (NEW.isbn IS NULL)) OR (OLD.isbn != NEW.isbn)) THEN
        PERFORM nex.insertupdatelog('BOOK'::text, 'ISBN'::text, OLD.book_id, OLD.isbn, NEW.isbn, USER);
    END IF;

    IF (((OLD.total_pages IS NULL) AND (NEW.total_pages IS NOT NULL)) OR ((OLD.total_pages IS NOT NULL) AND (NEW.total_pages IS NULL)) OR (OLD.total_pages != NEW.total_pages)) THEN
        PERFORM nex.insertupdatelog('BOOK'::text, 'TOTAL_PAGES'::text, OLD.book_id, OLD.total_pages::text, NEW.total_pages::text, USER);
    END IF;

    IF (((OLD.publisher IS NULL) AND (NEW.publisher IS NOT NULL)) OR ((OLD.publisher IS NOT NULL) AND (NEW.publisher IS NULL)) OR (OLD.publisher != NEW.publisher)) THEN
        PERFORM nex.insertupdatelog('BOOK'::text, 'PUBLISHER'::text, OLD.book_id, OLD.publisher, NEW.publisher, USER);
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.book_id || '[:]' || OLD.format_name || '[:]' ||
             OLD.display_name || '[:]' || OLD.obj_url || '[:]' ||
             OLD.source_id || '[:]' || coalesce(OLD.bud_id,0) || '[:]' ||
             OLD.title || '[:]' || coalesce(OLD.volume_title,'') || '[:]' ||
             coalesce(OLD.isbn,'') || '[:]' || coalesce(OLD.total_pages,0) || '[:]' ||
             coalesce(OLD.publisher,'') || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

          PERFORM nex.insertdeletelog('BOOK'::text, OLD.book_id, v_row, USER);

     RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER book_audr
AFTER UPDATE OR DELETE ON nex.book FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_book_audr();

DROP TRIGGER IF EXISTS book_biur ON nex.book CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_book_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := upper(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;

  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.book_id != OLD.book_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER book_biur
BEFORE INSERT OR UPDATE ON nex.book FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_book_biur();

DROP TRIGGER IF EXISTS journal_audr ON nex.journal CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_journal_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

    IF (OLD.format_name != NEW.format_name) THEN
        PERFORM nex.insertupdatelog('JOURNAL'::text, 'FORMAT_NAME'::text, OLD.journal_id, OLD.format_name, NEW.format_name, USER);
    END IF;

     IF (OLD.display_name != NEW.display_name) THEN
        PERFORM nex.insertupdatelog('JOURNAL'::text, 'DISPLAY_NAME'::text, OLD.journal_id, OLD.display_name, NEW.display_name, USER);
    END IF;

    IF (OLD.obj_url != NEW.obj_url) THEN
        PERFORM nex.insertupdatelog('JOURNAL'::text, 'OBJ_URL'::text, OLD.journal_id, OLD.obj_url, NEW.obj_url, USER);
    END IF;

     IF (OLD.source_id != NEW.source_id) THEN
        PERFORM nex.insertupdatelog('JOURNAL'::text, 'SOURCE_ID'::text, OLD.journal_id, OLD.source_id::text, NEW.source_id::text, USER);
    END IF;

    IF (((OLD.bud_id IS NULL) AND (NEW.bud_id IS NOT NULL)) OR ((OLD.bud_id IS NOT NULL) AND (NEW.bud_id IS NULL)) OR (OLD.bud_id != NEW.bud_id)) THEN
        PERFORM nex.insertupdatelog('JOURNAL'::text, 'BUD_ID'::text, OLD.journal_id, OLD.bud_id::text, NEW.bud_id::text, USER);
    END IF;

    IF (((OLD.med_abbr IS NULL) AND (NEW.med_abbr IS NOT NULL)) OR ((OLD.med_abbr IS NOT NULL) AND (NEW.med_abbr IS NULL)) OR (OLD.med_abbr != NEW.med_abbr)) THEN
        PERFORM nex.insertupdatelog('Journal'::text, 'MED_ABBR'::text, OLD.journal_id, OLD.med_abbr, NEW.med_abbr, USER);
    END IF;

    IF (((OLD.title IS NULL) AND (NEW.title IS NOT NULL)) OR ((OLD.title IS NOT NULL) AND (NEW.title IS NULL)) OR (OLD.title != NEW.title)) THEN
        PERFORM nex.insertupdatelog('Journal'::text, 'TITLE'::text, OLD.journal_id, OLD.title, NEW.title, USER);
    END IF;

    IF (((OLD.issn_print IS NULL) AND (NEW.issn_print IS NOT NULL)) OR ((OLD.issn_print IS NOT NULL) AND (NEW.issn_print IS NULL)) OR (OLD.issn_print != NEW.issn_print)) THEN
        PERFORM nex.insertupdatelog('Journal'::text, 'ISSN_PRINT'::text, OLD.journal_id, OLD.issn_print, NEW.issn_print, USER);
    END IF;

    IF (((OLD.issn_electronic IS NULL) AND (NEW.issn_electronic IS NOT NULL)) OR ((OLD.issn_electronic IS NOT NULL) AND (NEW.issn_electronic IS NULL)) OR (OLD.issn_electronic != NEW.issn_electronic)) THEN
        PERFORM nex.insertupdatelog('Journal'::text, 'ISSN_ELECTRONIC'::text, OLD.journal_id, OLD.issn_electronic, NEW.issn_electronic, USER);
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.journal_id || '[:]' || OLD.format_name || '[:]' ||
             OLD.display_name || '[:]' || OLD.obj_url || '[:]' ||
             OLD.source_id || '[:]' || coalesce(OLD.bud_id,0) || '[:]' ||
             coalesce(OLD.med_abbr,'') || '[:]' || coalesce(OLD.title,'') || '[:]' ||
             coalesce(OLD.issn_print,'') || '[:]' || coalesce(OLD.issn_electronic,'') || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

           PERFORM nex.insertdeletelog('JOURNAL'::text, OLD.journal_id, v_row, USER);

     RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER journal_audr
AFTER UPDATE OR DELETE ON nex.journal FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_journal_audr();

DROP TRIGGER IF EXISTS journal_biur ON nex.journal CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_journal_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := upper(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;

  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.journal_id != OLD.journal_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER journal_biur
BEFORE INSERT OR UPDATE ON nex.journal FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_journal_biur();

DROP TRIGGER IF EXISTS referencedbentity_audr ON nex.referencedbentity CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_referencedbentity_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
   v_sgdid   	nex.dbentity.sgdid%TYPE;
BEGIN
  If (TG_OP = 'UPDATE') THEN

    IF (OLD.method_obtained != NEW.method_obtained) THEN
        PERFORM nex.insertupdatelog('REFERENCE'::text, 'METHOD_OBTAINED'::text, OLD.dbentity_id, OLD.method_obtained, NEW.method_obtained, USER);
    END IF;

    IF (OLD.publication_status != NEW.publication_status) THEN
        PERFORM nex.insertupdatelog('REFERENCE'::text, 'PUBLICATION_STATUS'::text, OLD.dbentity_id, OLD.publication_status, NEW.publication_status, USER);
    END IF;

    IF (OLD.fulltext_status != NEW.fulltext_status) THEN
        PERFORM nex.insertupdatelog('REFERENCE'::text, 'FULLTEXT_STATUS'::text, OLD.dbentity_id, OLD.fulltext_status, NEW.fulltext_status, USER);
    END IF;

    IF (OLD.citation != NEW.citation) THEN
        PERFORM nex.insertupdatelog('REFERENCE'::text, 'CITATION'::text, OLD.dbentity_id, OLD.citation, NEW.citation, USER);
    END IF;

    IF (OLD.year != NEW.year) THEN
        PERFORM nex.insertupdatelog('REFERENCE'::text, 'YEAR'::text, OLD.dbentity_id, OLD.year::text, NEW.year::text, USER);
    END IF;

    IF (((OLD.pmid IS NULL) AND (NEW.pmid IS NOT NULL)) OR ((OLD.pmid IS NOT NULL) AND (NEW.pmid IS NULL)) OR (OLD.pmid != NEW.pmid)) THEN
        PERFORM nex.insertupdatelog('REFERENCE'::text, 'PMID'::text, OLD.dbentity_id, OLD.pmid::text, NEW.pmid::text, USER);
    END IF;

    IF (((OLD.pmcid IS NULL) AND (NEW.pmcid IS NOT NULL)) OR ((OLD.pmcid IS NOT NULL) AND (NEW.pmcid IS NULL)) OR (OLD.pmcid != NEW.pmcid)) THEN
        PERFORM nex.insertupdatelog('REFERENCE'::text, 'PMCID'::text, OLD.dbentity_id, OLD.pmcid, NEW.pmcid, USER);
    END IF;

    IF (((OLD.date_published IS NULL) AND (NEW.date_published IS NOT NULL)) OR ((OLD.date_published IS NOT NULL) AND (NEW.date_published IS NULL)) OR (OLD.date_published != NEW.date_published)) THEN
        PERFORM nex.insertupdatelog('REFERENCE'::text, 'DATE_PUBLISHED'::text, OLD.dbentity_id, OLD.date_published, NEW.date_published, USER);
    END IF;

    IF (((OLD.date_revised IS NULL) AND (NEW.date_revised IS NOT NULL)) OR ((OLD.date_revised IS NOT NULL) AND (NEW.date_revised IS NULL)) OR (OLD.date_revised != NEW.date_revised)) THEN
        PERFORM nex.insertupdatelog('REFERENCE'::text, 'DATE_REVISED'::text, OLD.dbentity_id, OLD.date_revised::text, NEW.date_revised::text, USER);
    END IF;

    IF (((OLD.issue IS NULL) AND (NEW.issue IS NOT NULL)) OR ((OLD.issue IS NOT NULL) AND (NEW.issue IS NULL)) OR (OLD.issue != NEW.issue)) THEN
        PERFORM nex.insertupdatelog('REFERENCE'::text, 'ISSUE'::text, OLD.dbentity_id, OLD.issue, NEW.issue, USER);
    END IF;

    IF (((OLD.page IS NULL) AND (NEW.page IS NOT NULL)) OR ((OLD.page IS NOT NULL) AND (NEW.page IS NULL)) OR (OLD.page != NEW.page)) THEN
        PERFORM nex.insertupdatelog('REFERENCE'::text, 'PAGE'::text, OLD.dbentity_id, OLD.page, NEW.page, USER);
    END IF;

    IF (((OLD.volume IS NULL) AND (NEW.volume IS NOT NULL)) OR ((OLD.volume IS NOT NULL) AND (NEW.volume IS NULL)) OR (OLD.volume != NEW.volume)) THEN
        PERFORM nex.insertupdatelog('REFERENCE'::text, 'VOLUME'::text, OLD.dbentity_id, OLD.volume, NEW.volume, USER);
    END IF;

    IF (((OLD.title IS NULL) AND (NEW.title IS NOT NULL)) OR ((OLD.title IS NOT NULL) AND (NEW.title IS NULL)) OR (OLD.title != NEW.title)) THEN
        PERFORM nex.insertupdatelog('REFERENCE'::text, 'TITLE'::text, OLD.dbentity_id, OLD.title, NEW.title, USER);
    END IF;

    IF (((OLD.doi IS NULL) AND (NEW.doi IS NOT NULL)) OR ((OLD.doi IS NOT NULL) AND (NEW.doi IS NULL)) OR (OLD.doi != NEW.doi)) THEN
        PERFORM nex.insertupdatelog('REFERENCE'::text, 'DOI'::text, OLD.dbentity_id, OLD.doi, NEW.doi, USER);
    END IF;

    IF (((OLD.journal_id IS NULL) AND (NEW.journal_id IS NOT NULL)) OR ((OLD.journal_id IS NOT NULL) AND (NEW.journal_id IS NULL)) OR (OLD.journal_id != NEW.journal_id)) THEN
        PERFORM nex.insertupdatelog('REFERENCE'::text, 'JOURNAL_ID'::text, OLD.dbentity_id, OLD.journal_id::text, NEW.journal_id::text, USER);
    END IF;

    IF (((OLD.book_id IS NULL) AND (NEW.book_id IS NOT NULL)) OR ((OLD.book_id IS NOT NULL) AND (NEW.book_id IS NULL)) OR (OLD.book_id != NEW.book_id)) THEN
        PERFORM nex.insertupdatelog('REFERENCE'::text, 'BOOK_ID'::text, OLD.dbentity_id, OLD.book_id::text, NEW.book_id::text, USER);
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

        SELECT sgdid INTO v_sgdid
	    FROM nex.dbentity
	    WHERE dbentity_id = OLD.dbentity_id;

        UPDATE nex.sgdid SET sgdid_status = 'Deleted'
        WHERE display_name = v_sgdid;
	
       v_row := OLD.dbentity_id || '[:]' || OLD.method_obtained || '[:]' ||
                OLD.publication_status || '[:]' ||
                OLD.fulltext_status || '[:]' || OLD.citation || '[:]' ||
                OLD.year || '[:]' || coalesce(OLD.pmid,0) || '[:]' ||
                coalesce(OLD.pmcid,'') || '[:]' || coalesce(OLD.date_published,'') || '[:]' ||
                coalesce(OLD.date_revised,'1000-01-01') || '[:]' || coalesce(OLD.issue,'') || '[:]' ||
                coalesce(OLD.page,'') || '[:]' || coalesce(OLD.volume,'') || '[:]' ||
                coalesce(OLD.title,'') || '[:]' || coalesce(OLD.doi,'') || '[:]' ||
                coalesce(OLD.journal_id,0) || '[:]' || coalesce(OLD.book_id,0);

           PERFORM nex.insertdeletelog('REFERENCE'::text, OLD.dbentity_id, v_row, USER);

       RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER referencedbentity_audr
AFTER UPDATE OR DELETE ON nex.referencedbentity FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_referencedbentity_audr();

DROP TRIGGER IF EXISTS referencedbentity_biur ON nex.referencedbentity CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_referencedbentity_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

    IF ((NEW.journal_id IS NOT NULL) AND (NEW.book_id IS NOT NULL)) THEN
        RAISE EXCEPTION 'journal_id and book_id can not both be NOT NULL.';
    END IF;

    IF ((NEW.journal_id IS NOT NULL) AND (NEW.publication_status = 'Published') AND (NEW.pmid IS NOT NULL)) THEN
        IF (NEW.title IS NULL) THEN
            RAISE EXCEPTION 'Reference title must be entered if there is a Pmid.';
        END IF;
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.dbentity_id != OLD.dbentity_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF ((NEW.journal_id IS NOT NULL) AND (NEW.book_id IS NOT NULL)) THEN
        RAISE EXCEPTION 'journal_id and book_id can not both be NOT NULL.';
    END IF;

    IF ((NEW.journal_id IS NOT NULL) AND (NEW.publication_status = 'Published') AND (NEW.pmid IS NOT NULL)) THEN
        IF (NEW.title IS NULL) THEN
            RAISE EXCEPTION 'Reference title must be entered if there is a Pmid.';
        END IF;
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER referencedbentity_biur
BEFORE INSERT OR UPDATE ON nex.referencedbentity FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_referencedbentity_biur();

DROP TRIGGER IF EXISTS referencealias_audr ON nex.reference_alias CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_referencealias_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

    IF (OLD.display_name != NEW.display_name) THEN
        PERFORM nex.insertupdatelog('REFERENCE_ALIAS'::text, 'DISPLAY_NAME'::text, OLD.alias_id, OLD.display_name, NEW.display_name, USER);
    END IF;

     IF (OLD.source_id != NEW.source_id) THEN
        PERFORM nex.insertupdatelog('REFERENCE_ALIAS'::text, 'SOURCE_ID'::text, OLD.alias_id, OLD.source_id::text, NEW.source_id::text, USER);
    END IF;

    IF (((OLD.bud_id IS NULL) AND (NEW.bud_id IS NOT NULL)) OR ((OLD.bud_id IS NOT NULL) AND (NEW.bud_id IS NULL)) OR (OLD.bud_id != NEW.bud_id)) THEN
        PERFORM nex.insertupdatelog('REFERENCE_ALIAS'::text, 'BUD_ID'::text, OLD.alias_id, OLD.bud_id::text, NEW.bud_id::text, USER);
    END IF;

    IF (OLD.reference_id != NEW.reference_id) THEN
        PERFORM nex.insertupdatelog('REFERENCE_ALIAS'::text, 'REFERENCE_ID'::text, OLD.alias_id, OLD.reference_id::text, NEW.reference_id::text, USER);
    END IF;

    IF (OLD.alias_type != NEW.alias_type) THEN
        PERFORM nex.insertupdatelog('REFERENCE_ALIAS'::text, 'ALIAS_TYPE'::text, OLD.alias_id, OLD.alias_type, NEW.alias_type, USER);
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN
  
    v_row := OLD.alias_id || '[:]' || OLD.display_name || '[:]' || 
             OLD.source_id || '[:]' || coalesce(OLD.bud_id,0) || '[:]' ||
             OLD.reference_id || '[:]' || OLD.alias_type || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

         PERFORM nex.insertdeletelog('REFERENCE_ALIAS'::text, OLD.alias_id, v_row, USER);

     RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER referencealias_audr
AFTER UPDATE OR DELETE ON nex.reference_alias FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_referencealias_audr();

DROP TRIGGER IF EXISTS referencealias_biur ON nex.reference_alias CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_referencealias_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := upper(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;

  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.alias_id != OLD.alias_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;
    
    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER referencealias_biur
BEFORE INSERT OR UPDATE ON nex.reference_alias FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_referencealias_biur();

DROP TRIGGER IF EXISTS referencerelation_audr ON nex.reference_relation CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_referencerelation_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

     IF (OLD.source_id != NEW.source_id) THEN
        PERFORM nex.insertupdatelog('REFERENCE_RELATION'::text, 'SOURCE_ID'::text, OLD.reference_relation_id, OLD.source_id::text, NEW.source_id::text, USER);
    END IF;

     IF (OLD.parent_id != NEW.parent_id) THEN
        PERFORM nex.insertupdatelog('REFERENCE_RELATION'::text, 'PARENT_ID'::text, OLD.reference_relation_id, OLD.parent_id::text, NEW.parent_id::text, USER);
    END IF;

     IF (OLD.child_id != NEW.child_id) THEN
        PERFORM nex.insertupdatelog('REFERENCE_RELATION'::text, 'CHILD_ID'::text, OLD.reference_relation_id, OLD.child_id::text, NEW.child_id::text, USER);
    END IF;

    IF (OLD.correction_type != NEW.correction_type) THEN
        PERFORM nex.insertupdatelog('REFERENCE_RELATION'::text, 'CORRECTION_TYPE'::text, OLD.reference_relation_id, OLD.correction_type, NEW.correction_type, USER);
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.reference_relation_id || '[:]' || OLD.source_id || '[:]' ||
             OLD.parent_id || '[:]' || OLD.child_id || '[:]' ||
             OLD.correction_type || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

          PERFORM nex.insertdeletelog('REFERENCE_RELATION'::text, OLD.reference_relation_id, v_row, USER);

     RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER referencerelation_audr
AFTER UPDATE OR DELETE ON nex.reference_relation FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_referencerelation_audr();

DROP TRIGGER IF EXISTS referencerelation_biur ON nex.reference_relation CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_referencerelation_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := upper(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;

  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.reference_relation_id != OLD.reference_relation_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER referencerelation_biur
BEFORE INSERT OR UPDATE ON nex.reference_relation FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_referencerelation_biur();

DROP TRIGGER IF EXISTS referenceurl_audr ON nex.reference_url CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_referenceurl_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

    IF (OLD.display_name != NEW.display_name) THEN
        PERFORM nex.insertupdatelog('REFERENCE_URL'::text, 'DISPLAY_NAME'::text, OLD.url_id, OLD.display_name, NEW.display_name, USER);
    END IF;

    IF (OLD.obj_url != NEW.obj_url) THEN
        PERFORM nex.insertupdatelog('REFERENCE_URL'::text, 'OBJ_URL'::text, OLD.url_id, OLD.obj_url, NEW.obj_url, USER);
    END IF;

     IF (OLD.source_id != NEW.source_id) THEN
        PERFORM nex.insertupdatelog('REFERENCE_URL'::text, 'SOURCE_ID'::text, OLD.url_id, OLD.source_id::text, NEW.source_id::text, USER);
    END IF;

    IF (((OLD.bud_id IS NULL) AND (NEW.bud_id IS NOT NULL)) OR ((OLD.bud_id IS NOT NULL) AND (NEW.bud_id IS NULL)) OR (OLD.bud_id != NEW.bud_id)) THEN
        PERFORM nex.insertupdatelog('REFERENCE_URL'::text, 'BUD_ID'::text, OLD.url_id, OLD.bud_id::text, NEW.bud_id::text, USER);
    END IF;

    IF (OLD.reference_id != NEW.reference_id) THEN
        PERFORM nex.insertupdatelog('REFERENCE_URL'::text, 'REFERENCE_ID'::text, OLD.url_id, OLD.reference_id::text, NEW.reference_id::text, USER);
    END IF;

    IF (OLD.url_type != NEW.url_type) THEN
        PERFORM nex.insertupdatelog('REFERENCE_URL'::text, 'URL_TYPE'::text, OLD.url_id, OLD.url_type, NEW.url_type, USER);
    END IF;

    RETURN NEW;
    
  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.url_id || '[:]' ||
	     OLD.display_name || '[:]' || OLD.obj_url || '[:]' ||
             OLD.source_id || '[:]' || coalesce(OLD.bud_id,0) || '[:]' ||
             OLD.reference_id || '[:]' || OLD.url_type || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

          PERFORM nex.insertdeletelog('REFERENCE_URL'::text, OLD.url_id, v_row, USER);

     RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER referenceurl_audr
AFTER UPDATE OR DELETE ON nex.reference_url FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_referenceurl_audr();

DROP TRIGGER IF EXISTS referenceurl_biur ON nex.reference_url CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_referenceurl_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := upper(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;
  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.url_id != OLD.url_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER referenceurl_biur
BEFORE INSERT OR UPDATE ON nex.reference_url FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_referenceurl_biur();

DROP TRIGGER IF EXISTS referenceauthor_audr ON nex.referenceauthor CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_referenceauthor_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

     IF (OLD.display_name != NEW.display_name) THEN
        PERFORM nex.insertupdatelog('REFERENCEAUTHOR'::text, 'DISPLAY_NAME'::text, OLD.referenceauthor_id, OLD.display_name, NEW.display_name, USER);
    END IF;

    IF (OLD.obj_url != NEW.obj_url) THEN
        PERFORM nex.insertupdatelog('REFERENCEAUTHOR'::text, 'OBJ_URL'::text, OLD.referenceauthor_id, OLD.obj_url, NEW.obj_url, USER);
    END IF;

     IF (OLD.source_id != NEW.source_id) THEN
        PERFORM nex.insertupdatelog('REFERENCEAUTHOR'::text, 'SOURCE_ID'::text, OLD.referenceauthor_id, OLD.source_id::text, NEW.source_id::text, USER);
    END IF;

    IF (((OLD.bud_id IS NULL) AND (NEW.bud_id IS NOT NULL)) OR ((OLD.bud_id IS NOT NULL) AND (NEW.bud_id IS NULL)) OR (OLD.bud_id != NEW.bud_id)) THEN
        PERFORM nex.insertupdatelog('REFERENCEAUTHOR'::text, 'BUD_ID'::text, OLD.referenceauthor_id, OLD.bud_id::text, NEW.bud_id::text, USER);
    END IF;

    IF (OLD.reference_id != NEW.reference_id) THEN
        PERFORM nex.insertupdatelog('REFERENCEAUTHOR'::text, 'REFERENCE_ID'::text, OLD.referenceauthor_id, OLD.reference_id::text, NEW.reference_id::text, USER);
    END IF;

    IF (((OLD.orcid IS NULL) AND (NEW.orcid IS NOT NULL)) OR ((OLD.orcid IS NOT NULL) AND (NEW.orcid IS NULL)) OR (OLD.orcid != NEW.orcid)) THEN
        PERFORM nex.insertupdatelog('REFERENCEAUTHOR'::text, 'ORCID'::text, OLD.referenceauthor_id, OLD.orcid, NEW.orcid, USER);
    END IF;

     IF (OLD.author_order != NEW.author_order) THEN
        PERFORM nex.insertupdatelog('REFERENCEAUTHOR'::text, 'AUTHOR_ORDER'::text, OLD.referenceauthor_id, OLD.author_order::text, NEW.author_order::text, USER);
    END IF;

     IF (OLD.author_type != NEW.author_type) THEN
        PERFORM nex.insertupdatelog('REFERENCEAUTHOR'::text, 'AUTHOR_TYPE'::text, OLD.referenceauthor_id, OLD.author_type, NEW.author_type, USER);
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.referenceauthor_id || '[:]' || OLD.display_name || '[:]' ||
             OLD.obj_url || '[:]' || OLD.source_id || '[:]' ||
             coalesce(OLD.bud_id,0) || '[:]' || OLD.reference_id || '[:]' ||
             coalesce(OLD.orcid,'') || '[:]' || OLD.author_order || '[:]' ||
             OLD.author_type || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

        PERFORM nex.insertdeletelog('REFERENCEAUTHOR'::text, OLD.referenceauthor_id, v_row, USER);

    RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER referenceauthor_audr
AFTER UPDATE OR DELETE ON nex.referenceauthor FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_referenceauthor_audr();

DROP TRIGGER IF EXISTS referenceauthor_biur ON nex.referenceauthor CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_referenceauthor_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := upper(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;

  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.referenceauthor_id != OLD.referenceauthor_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER referenceauthor_biur
BEFORE INSERT OR UPDATE ON nex.referenceauthor FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_referenceauthor_biur();

DROP TRIGGER IF EXISTS referencedeleted_audr ON nex.referencedeleted CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_referencedeleted_audr() RETURNS trigger AS $BODY$
DECLARE
  v_row		nex.deletelog.deleted_row%TYPE;
BEGIN

  IF (TG_OP = 'UPDATE') THEN

    IF (OLD.pmid != NEW.pmid) THEN
        PERFORM nex.insertupdatelog('REFERENCEDELETED'::text, 'PMID'::text, OLD.referencedeleted_id, OLD.pmid::text, NEW.pmid::text, USER);
    END IF;

    IF (((OLD.sgdid IS NULL) AND (NEW.sgdid IS NOT NULL)) OR ((OLD.sgdid IS NOT NULL) AND (NEW.sgdid IS NULL)) OR (OLD.sgdid != NEW.sgdid)) THEN
        PERFORM nex.insertupdatelog('REFERENCEDELETED'::text, 'SGDID'::text, OLD.referencedeleted_id, OLD.sgdid, NEW.sgdid, USER);
    END IF;

    IF (((OLD.reason_deleted IS NULL) AND (NEW.reason_deleted IS NOT NULL)) OR ((OLD.reason_deleted IS NOT NULL) AND (NEW.reason_deleted IS NULL)) OR (OLD.reason_deleted != NEW.reason_deleted)) THEN
        PERFORM nex.insertupdatelog('REFERENCEDELETED'::text, 'REASON_DELETED'::text, OLD.referencedeleted_id, OLD.reason_deleted, NEW.reason_deleted, USER);
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

     v_row := OLD.referencedeleted_id || '[:]' || OLD.pmid || '[:]' ||
              coalesce(OLD.sgdid,'') || '[:]' || coalesce(OLD.reason_deleted,'') || '[:]' ||
              OLD.date_created || '[:]' || OLD.created_by;

           PERFORM nex.insertdeletelog('REFERENCEDELETED'::text, OLD.referencedeleted_id, v_row, USER);

     RETURN OLD;

  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER referencedeleted_audr
AFTER UPDATE OR DELETE ON nex.referencedeleted FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_referencedeleted_audr();

DROP TRIGGER IF EXISTS referencedeleted_biur ON nex.referencedeleted CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_referencedeleted_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

    PERFORM nex.checkpubmed(NEW.pmid);

    IF (NEW.sgdid IS NOT NULL) THEN
      PERFORM nex.checksgdid(NEW.sgdid);
    END IF;

    NEW.created_by := upper(NEW.created_by);
    PERFORM nex.checkuser(NEW.created_by);

    RETURN NEW;

  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.referencedeleted_id != OLD.referencedeleted_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    PERFORM nex.checkpubmed(NEW.pmid);

    IF (NEW.sgdid IS NOT NULL) THEN
      PERFORM nex.checksgdid(NEW.sgdid);
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER referencedeleted_biur
BEFORE INSERT OR UPDATE ON nex.referencedeleted FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_referencedeleted_biur();

DROP TRIGGER IF EXISTS referencedocument_audr ON nex.referencedocument CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_referencedocument_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

    IF (OLD.document_type != NEW.document_type) THEN
        PERFORM nex.insertupdatelog('REFERENCEDOCUMENT'::text, 'DOCUMENT_TYPE'::text, OLD.referencedocument_id, OLD.document_type, NEW.document_type, USER);
    END IF;

     IF (OLD.text != NEW.text) THEN
        PERFORM nex.insertupdatelog('REFERENCEDOCUMENT'::text, 'TEXT'::text, OLD.referencedocument_id, OLD.text, NEW.text, USER);
    END IF;

    IF (OLD.html != NEW.html) THEN
        PERFORM nex.insertupdatelog('REFERENCEDOCUMENT'::text, 'HTML'::text, OLD.referencedocument_id, OLD.html, NEW.html, USER);
    END IF;

     IF (OLD.source_id != NEW.source_id) THEN
        PERFORM nex.insertupdatelog('REFERENCEDOCUMENT'::text, 'SOURCE_ID'::text, OLD.referencedocument_id, OLD.source_id::text, NEW.source_id::text, USER);
    END IF;

     IF (OLD.reference_id != NEW.reference_id) THEN
        PERFORM nex.insertupdatelog('REFERENCEDOCUMENT'::text, 'REFERENCE_ID'::text, OLD.referencedocument_id, OLD.reference_id::text, NEW.reference_id::text, USER);
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.referencedocument_id || '[:]' || OLD.document_type || '[:]' ||
             OLD.text || '[:]' || OLD.html || '[:]' ||
             OLD.source_id || '[:]' || OLD.reference_id || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

          PERFORM nex.insertdeletelog('REFERENCEDOCUMENT'::text, OLD.referencedocument_id, v_row, USER);

     RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER referencedocument_audr
AFTER UPDATE OR DELETE ON nex.referencedocument FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_referencedocument_audr();

DROP TRIGGER IF EXISTS referencedocument_biur ON nex.referencedocument CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_referencedocument_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := upper(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;
       
  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.referencedocument_id != OLD.referencedocument_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER referencedocument_biur
BEFORE INSERT OR UPDATE ON nex.referencedocument FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_referencedocument_biur();

DROP TRIGGER IF EXISTS referencetype_audr ON nex.referencetype CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_referencetype_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

     IF (OLD.display_name != NEW.display_name) THEN
        PERFORM nex.insertupdatelog('REFERENCETYPE'::text, 'DISPLAY_NAME'::text, OLD.referencetype_id, OLD.display_name, NEW.display_name, USER);
    END IF;

    IF (OLD.obj_url != NEW.obj_url) THEN
        PERFORM nex.insertupdatelog('REFERENCETYPE'::text, 'OBJ_URL'::text, OLD.referencetype_id, OLD.obj_url, NEW.obj_url, USER);
    END IF;

     IF (OLD.source_id != NEW.source_id) THEN
        PERFORM nex.insertupdatelog('REFERENCETYPE'::text, 'SOURCE_ID'::text, OLD.referencetype_id, OLD.source_id::text, NEW.source_id::text, USER);
    END IF;

    IF (((OLD.bud_id IS NULL) AND (NEW.bud_id IS NOT NULL)) OR ((OLD.bud_id IS NOT NULL) AND (NEW.bud_id IS NULL)) OR (OLD.bud_id != NEW.bud_id)) THEN
        PERFORM nex.insertupdatelog('REFERENCETYPE'::text, 'BUD_ID'::text, OLD.referencetype_id, OLD.bud_id::text, NEW.bud_id::text, USER);
    END IF;

    IF (OLD.reference_id != NEW.reference_id) THEN
        PERFORM nex.insertupdatelog('REFERENCETYPE'::text, 'REFERENCE_ID'::text, OLD.referencetype_id, OLD.reference_id::text, NEW.reference_id::text, USER);
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.referencetype_id || '[:]' || OLD.display_name || '[:]' ||
             OLD.obj_url || '[:]' || OLD.source_id || '[:]' ||
             coalesce(OLD.bud_id,0) || '[:]' || OLD.reference_id || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

          PERFORM nex.insertdeletelog('REFERENCETYPE'::text, OLD.referencetype_id, v_row, USER);

     RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER referencetype_audr
AFTER UPDATE OR DELETE ON nex.referencetype FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_referencetype_audr();

DROP TRIGGER IF EXISTS referencetype_biur ON nex.referencetype CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_referencetype_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := upper(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;

  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.referencetype_id != OLD.referencetype_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER referencetype_biur
BEFORE INSERT OR UPDATE ON nex.referencetype FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_referencetype_biur();

DROP TRIGGER IF EXISTS referenceunlink_audr ON nex.referenceunlink CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_referenceunlink_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

    IF (OLD.reference_id != NEW.reference_id ) THEN
        PERFORM nex.insertupdatelog('REFERENCEUNLINK'::text, 'REFERENCE_ID'::text, OLD.referenceunlink_id, OLD.reference_id::text, NEW.reference_id::text, USER);
    END IF;

    IF (OLD.dbentity_id != NEW.dbentity_id) THEN
        PERFORM nex.insertupdatelog('REFERENCEUNLINK'::text, 'DBENTITY_ID'::text, OLD.referenceunlink_id, OLD.dbentity_id::text, NEW.dbentity_id::text, USER);
    END IF;

    IF (((OLD.bud_id IS NULL) AND (NEW.bud_id IS NOT NULL)) OR ((OLD.bud_id IS NOT NULL) AND (NEW.bud_id IS NULL)) OR (OLD.bud_id != NEW.bud_id)) THEN
        PERFORM nex.insertupdatelog('REFERENCEUNLINK'::text, 'BUD_ID'::text, OLD.referenceunlink_id, OLD.bud_id::text, NEW.bud_id::text, USER);
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.referenceunlink_id || '[:]' || OLD.reference_id || '[:]' ||
             OLD.dbentity_id || '[:]' || coalesce(OLD.bud_id,0) || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

          PERFORM nex.insertdeletelog('REFERENCEUNLINK'::text, OLD.referenceunlink_id, v_row, USER);

     RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER referenceunlink_audr
AFTER UPDATE OR DELETE ON nex.referenceunlink FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_referenceunlink_audr();

DROP TRIGGER IF EXISTS referenceunlink_biur ON nex.referenceunlink CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_referenceunlink_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := upper(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;

  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.referenceunlink_id != OLD.referenceunlink_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER referenceunlink_biur
BEFORE INSERT OR UPDATE ON nex.referenceunlink FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_referenceunlink_biur();

DROP TRIGGER IF EXISTS referencefile_audr ON nex.reference_file CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_referencefile_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

     IF (OLD.reference_id != NEW.reference_id) THEN
        PERFORM nex.insertupdatelog('REFERENCE_FILE'::text, 'REFERENCE_ID'::text, OLD.reference_file_id, OLD.reference_id::text, NEW.reference_id::text, USER);
    END IF;

    IF (OLD.file_id != NEW.file_id) THEN
        PERFORM nex.insertupdatelog('REFERENCE_FILE'::text, 'FILE_ID'::text, OLD.reference_file_id, OLD.file_id::text, NEW.file_id::text, USER);
    END IF;

     IF (OLD.source_id != NEW.source_id) THEN
        PERFORM nex.insertupdatelog('REFERENCE_FILE'::text, 'SOURCE_ID'::text, OLD.reference_file_id, OLD.source_id::text, NEW.source_id::text, USER);
    END IF;

    RETURN  NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.reference_file_id || '[:]' || OLD.reference_id || '[:]' ||
             OLD.file_id || '[:]' || OLD.source_id || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

          PERFORM nex.insertdeletelog('REFERENCE_FILE'::text, OLD.reference_file_id, v_row, USER);

     RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER referencefile_audr
AFTER UPDATE OR DELETE ON nex.reference_file FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_referencefile_audr();

DROP TRIGGER IF EXISTS referencefile_biur ON nex.reference_file CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_referencefile_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := upper(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;

  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.reference_file_id != OLD.reference_file_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER referencefile_biur
BEFORE INSERT OR UPDATE ON nex.reference_file FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_referencefile_biur();
