-- Generated by Ora2Pg, the Oracle database Schema converter, version 17.4
-- Copyright 2000-2016 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=sgd-nex2-db.stanford.edu;sid=SGD

SET client_encoding TO 'UTF8';

\set ON_ERROR_STOP ON

DROP TRIGGER IF EXISTS allele_audr ON nex.allele CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_allele_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

    IF (OLD.format_name != NEW.format_name) THEN
       PERFORM nex.insertupdatelog('ALLELE'::text, 'FORMAT_NAME'::text, OLD.allele_id, OLD.format_name, NEW.format_name, USER);
    END IF;

    IF (OLD.display_name != NEW.display_name) THEN
       PERFORM nex.insertupdatelog('ALLELE'::text, 'DISPLAY_NAME'::text, OLD.allele_id, OLD.display_name, NEW.display_name, USER);
    END IF;

    IF (OLD.obj_url != NEW.obj_url) THEN
       PERFORM nex.insertupdatelog('ALLELE'::text, 'OBJ_URL'::text, OLD.allele_id, OLD.obj_url, NEW.obj_url, USER);
    END IF;

     IF (OLD.source_id != NEW.source_id) THEN
       PERFORM nex.insertupdatelog('ALLELE'::text, 'SOURCE_ID'::text, OLD.allele_id, OLD.source_id::text, NEW.source_id::text, USER);
    END IF;

    IF (((OLD.bud_id IS NULL) AND (NEW.bud_id IS NOT NULL)) OR ((OLD.bud_id IS NOT NULL) AND (NEW.bud_id IS NULL)) OR (OLD.bud_id != NEW.bud_id)) THEN
       PERFORM nex.insertupdatelog('ALLELE'::text, 'BUD_ID'::text, OLD.allele_id, OLD.bud_id::text, NEW.bud_id::text, USER);
    END IF;

    IF (OLD.description != NEW.description) THEN
       PERFORM nex.insertupdatelog('ALLELE'::text, 'DESCRIPTION'::text, OLD.allele_id, OLD.description, NEW.description, USER);
    END IF;

    RETURN NEW;
    
  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.allele_id || '[:]' || OLD.format_name || '[:]' ||
	     OLD.display_name || '[:]' || OLD.obj_url || '[:]' ||
             OLD.source_id || '[:]' || coalesce(OLD.bud_id,0) || '[:]' ||
             OLD.description || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

            PERFORM nex.insertdeletelog('ALLELE'::text, OLD.allele_id, v_row, USER);

     RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER allele_audr
AFTER UPDATE OR DELETE ON nex.allele FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_allele_audr();

DROP TRIGGER IF EXISTS allele_biur ON nex.allele CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_allele_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := UPPER(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;

  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.allele_id != OLD.allele_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER allele_biur
BEFORE INSERT OR UPDATE ON nex.allele FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_allele_biur();


DROP TRIGGER IF EXISTS colleague_audr ON nex.colleague CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_colleague_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

    IF (OLD.format_name != NEW.format_name) THEN
       PERFORM nex.insertupdatelog('COLLEAGUE'::text, 'FORMAT_NAME'::text, OLD.colleague_id, OLD.format_name, NEW.format_name, USER);
    END IF;

    IF (OLD.display_name != NEW.display_name) THEN
       PERFORM nex.insertupdatelog('COLLEAGUE'::text, 'DISPLAY_NAME'::text, OLD.colleague_id, OLD.display_name, NEW.display_name, USER);
    END IF;

    IF (OLD.obj_url != NEW.obj_url) THEN
       PERFORM nex.insertupdatelog('COLLEAGUE'::text, 'OBJ_URL'::text, OLD.colleague_id, OLD.obj_url, NEW.obj_url, USER);
    END IF;

     IF (OLD.source_id != NEW.source_id) THEN
       PERFORM nex.insertupdatelog('COLLEAGUE'::text, 'SOURCE_ID'::text, OLD.colleague_id, OLD.source_id::text, NEW.source_id::text, USER);
    END IF;

    IF (((OLD.bud_id IS NULL) AND (NEW.bud_id IS NOT NULL)) OR ((OLD.bud_id IS NOT NULL) AND (NEW.bud_id IS NULL)) OR (OLD.bud_id != NEW.bud_id)) THEN
       PERFORM nex.insertupdatelog('COLLEAGUE'::text, 'BUD_ID'::text, OLD.colleague_id, OLD.bud_id::text, NEW.bud_id::text, USER);
    END IF;

     IF (((OLD.orcid IS NULL) AND (NEW.orcid IS NOT NULL)) OR ((OLD.orcid IS NOT NULL) AND (NEW.orcid IS NULL)) OR (OLD.orcid != NEW.orcid)) THEN
       PERFORM nex.insertupdatelog('COLLEAGUE'::text, 'ORCID'::text, OLD.colleague_id, OLD.orcid, NEW.orcid, USER);
    END IF;

    IF (OLD.last_name != NEW.last_name) THEN
       PERFORM nex.insertupdatelog('COLLEAGUE'::text, 'LAST_NAME'::text, OLD.colleague_id, OLD.last_name, NEW.last_name, USER);
    END IF;

    IF (((OLD.middle_name IS NULL) AND (NEW.middle_name IS NOT NULL)) OR ((OLD.middle_name IS NOT NULL) AND (NEW.middle_name IS NULL)) OR (OLD.middle_name != NEW.middle_name)) THEN
       PERFORM nex.insertupdatelog('COLLEAGUE'::text, 'MIDDLE_NAME'::text, OLD.colleague_id, OLD.middle_name, NEW.middle_name, USER);
    END IF;

    IF (OLD.first_name != NEW.first_name) THEN
       PERFORM nex.insertupdatelog('COLLEAGUE'::text, 'FIRST_NAME'::text, OLD.colleague_id, OLD.first_name, NEW.first_name, USER);
    END IF;

    IF  (((OLD.suffix IS NULL) AND (NEW.suffix IS NOT NULL)) OR ((OLD.suffix IS NOT NULL) AND (NEW.suffix IS NULL)) OR (OLD.suffix != NEW.suffix)) THEN
       PERFORM nex.insertupdatelog('COLLEAGUE'::text, 'SUFFIX'::text, OLD.colleague_id, OLD.suffix, NEW.suffix, USER);
    END IF;

    IF (((OLD.other_last_name IS NULL) AND (NEW.other_last_name IS NOT NULL)) OR ((OLD.other_last_name IS NOT NULL) AND (NEW.other_last_name IS NULL)) OR (OLD.other_last_name != NEW.other_last_name)) THEN
       PERFORM nex.insertupdatelog('COLLEAGUE'::text, 'OTHER_LAST_NAME'::text, OLD.colleague_id, OLD.other_last_name, NEW.other_last_name, USER);
    END IF;

    IF (((OLD.profession IS NULL) AND (NEW.profession IS NOT NULL)) OR ((OLD.profession IS NOT NULL) AND (NEW.profession IS NULL)) OR (OLD.profession != NEW.profession)) THEN
       PERFORM nex.insertupdatelog('COLLEAGUE'::text, 'PROFESSION'::text, OLD.colleague_id, OLD.profession, NEW.profession, USER);
    END IF;

    IF (((OLD.job_title IS NULL) AND (NEW.job_title IS NOT NULL)) OR ((OLD.job_title IS NOT NULL) AND (NEW.job_title IS NULL)) OR (OLD.job_title != NEW.job_title)) THEN
       PERFORM nex.insertupdatelog('COLLEAGUE'::text, 'JOB_TITLE'::text, OLD.colleague_id, OLD.job_title, NEW.job_title, USER);
    END IF;

    IF (((OLD.institution IS NULL) AND (NEW.institution IS NOT NULL)) OR ((OLD.institution IS NOT NULL) AND (NEW.institution IS NULL)) OR (OLD.institution != NEW.institution)) THEN
       PERFORM nex.insertupdatelog('COLLEAGUE'::text, 'INSTITUTION'::text, OLD.colleague_id, OLD.institution, NEW.institution, USER);
    END IF;

    IF (((OLD.address1 IS NULL) AND (NEW.address1 IS NOT NULL)) OR ((OLD.address1 IS NOT NULL) AND (NEW.address1 IS NULL)) OR (OLD.address1 != NEW.address1)) THEN
       PERFORM nex.insertupdatelog('COLLEAGUE'::text, 'ADDRESS1'::text, OLD.colleague_id, OLD.address1, NEW.address1, USER);
    END IF;

    IF (((OLD.address2 IS NULL) AND (NEW.address2 IS NOT NULL)) OR ((OLD.address2 IS NOT NULL) AND (NEW.address2 IS NULL)) OR (OLD.address2 != NEW.address2)) THEN
       PERFORM nex.insertupdatelog('COLLEAGUE'::text, 'ADDRESS2'::text, OLD.colleague_id, OLD.address2, NEW.address2, USER);
    END IF;

    IF (((OLD.address3 IS NULL) AND (NEW.address3 IS NOT NULL)) OR ((OLD.address3 IS NOT NULL) AND (NEW.address3 IS NULL)) OR (OLD.address3 != NEW.address3)) THEN
       PERFORM nex.insertupdatelog('COLLEAGUE'::text, 'ADDRESS3'::text, OLD.colleague_id, OLD.address3, NEW.address3, USER);
    END IF;

    IF (((OLD.city IS NULL) AND (NEW.city IS NOT NULL)) OR ((OLD.city IS NOT NULL) AND (NEW.city IS NULL)) OR (OLD.city != NEW.city)) THEN
       PERFORM nex.insertupdatelog('COLLEAGUE'::text, 'CITY'::text, OLD.colleague_id, OLD.city, NEW.city, USER);
    END IF;

    IF (((OLD.state IS NULL) AND (NEW.state IS NOT NULL)) OR ((OLD.state IS NOT NULL) AND (NEW.state IS NULL)) OR (OLD.state != NEW.state)) THEN
       PERFORM nex.insertupdatelog('COLLEAGUE'::text, 'STATE'::text, OLD.colleague_id, OLD.state, NEW.state, USER);
    END IF;

    IF (((OLD.country IS NULL) AND (NEW.country IS NOT NULL)) OR ((OLD.country IS NOT NULL) AND (NEW.country IS NULL)) OR (OLD.country != NEW.country)) THEN
       PERFORM nex.insertupdatelog('COLLEAGUE'::text, 'COUNTRY'::text, OLD.colleague_id, OLD.country, NEW.country, USER);
    END IF;

    IF (((OLD.postal_code IS NULL) AND (NEW.postal_code IS NOT NULL)) OR ((OLD.postal_code IS NOT NULL) AND (NEW.postal_code IS NULL)) OR (OLD.postal_code != NEW.postal_code)) THEN
       PERFORM nex.insertupdatelog('COLLEAGUE'::text, 'POSTAL_CODE'::text, OLD.colleague_id, OLD.postal_code, NEW.postal_code, USER);
    END IF;

    IF (((OLD.work_phone IS NULL) AND (NEW.work_phone IS NOT NULL)) OR ((OLD.work_phone IS NOT NULL) AND (NEW.work_phone IS NULL)) OR (OLD.work_phone != NEW.work_phone)) THEN
       PERFORM nex.insertupdatelog('COLLEAGUE'::text, 'WORK_PHONE'::text, OLD.colleague_id, OLD.work_phone, NEW.work_phone, USER);
    END IF;

    IF (((OLD.other_phone IS NULL) AND (NEW.other_phone IS NOT NULL)) OR ((OLD.other_phone IS NOT NULL) AND (NEW.other_phone IS NULL)) OR (OLD.other_phone != NEW.other_phone)) THEN
       PERFORM nex.insertupdatelog('COLLEAGUE'::text, 'OTHER_PHONE'::text, OLD.colleague_id, OLD.other_phone, NEW.other_phone, USER);
    END IF;

    IF (((OLD.email IS NULL) AND (NEW.email IS NOT NULL)) OR ((OLD.email IS NOT NULL) AND (NEW.email IS NULL)) OR (OLD.email != NEW.email)) THEN
       PERFORM nex.insertupdatelog('COLLEAGUE'::text, 'EMAIL'::text, OLD.colleague_id, OLD.email, NEW.email, USER);
    END IF;

    IF (((OLD.colleague_note IS NULL) AND (NEW.colleague_note IS NOT NULL)) OR ((OLD.colleague_note IS NOT NULL) AND (NEW.colleague_note IS NULL)) OR (OLD.colleague_note != NEW.colleague_note)) THEN
       PERFORM nex.insertupdatelog('COLLEAGUE'::text, 'COLLEAGUE_NOTE'::text, OLD.colleague_id, OLD.colleague_note, NEW.colleague_note, USER);
    END IF;

    IF (((OLD.research_interest IS NULL) AND (NEW.research_interest IS NOT NULL)) OR ((OLD.research_interest IS NOT NULL) AND (NEW.research_interest IS NULL)) OR (OLD.research_interest != NEW.research_interest)) THEN
       PERFORM nex.insertupdatelog('COLLEAGUE'::text, 'RESEARCH_INTEREST'::text, OLD.colleague_id, OLD.research_interest, NEW.research_interest, USER);
    END IF;

    IF (OLD.is_pi != NEW.is_pi) THEN
       PERFORM nex.insertupdatelog('COLLEAGUE'::text, 'IS_PI'::text, OLD.colleague_id, OLD.is_pi::text, NEW.is_pi::text, USER);
    END IF;

    IF (OLD.is_contact != NEW.is_contact) THEN
       PERFORM nex.insertupdatelog('COLLEAGUE'::text, 'IS_CONTACT'::text, OLD.colleague_id, OLD.is_contact::text, NEW.is_contact::text, USER);
    END IF;

    IF (OLD.is_beta_tester != NEW.is_beta_tester) THEN
       PERFORM nex.insertupdatelog('COLLEAGUE'::text, 'IS_BETA_TESTER'::text, OLD.colleague_id, OLD.is_beta_tester::text, NEW.is_beta_tester::text, USER);
    END IF;

    IF (OLD.display_email != NEW.display_email) THEN
       PERFORM nex.insertupdatelog('COLLEAGUE'::text, 'DISPLAY_EMAIL'::text, OLD.colleague_id, OLD.display_email, NEW.display_email, USER);
    END IF;

    IF (OLD.date_last_modified != NEW.date_last_modified) THEN
       PERFORM nex.insertupdatelog('COLLEAGUE'::text, 'DATE_LAST_MODIFIED'::text, OLD.colleague_id, OLD.date_last_modified::text, NEW.date_last_modified::text, USER);
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.colleague_id || '[:]' || OLD.format_name || '[:]' ||
             OLD.display_name || '[:]' || OLD.obj_url || '[:]' ||
             OLD.source_id || '[:]' || coalesce(OLD.bud_id,0) || '[:]' ||
             coalesce(OLD.orcid,0) || '[:]' || OLD.first_name || '[:]' ||
             coalesce(OLD.middle_name,'') || '[:]' || OLD.last_name || '[:]' ||
             coalesce(OLD.suffix,'') || '[:]' || coalesce(OLD.other_last_name,'') || '[:]' ||
             coalesce(OLD.profession,'') || '[:]' || coalesce(OLD.job_title,'') || '[:]' ||
             coalesce(OLD.institution,'') || '[:]' || coalesce(OLD.address1,'') || '[:]' ||
             coalesce(OLD.address2,'') || '[:]' || coalesce(OLD.address3,'') || '[:]' ||
             coalesce(OLD.city,'') || '[:]' || coalesce(OLD.state,'') || '[:]' ||
             coalesce(OLD.country,'') || '[:]' || coalesce(OLD.postal_code,'') || '[:]' ||
             coalesce(OLD.work_phone,'') || '[:]' || coalesce(OLD.other_phone,'') || '[:]' ||
             coalesce(OLD.email,'') || '[:]' || OLD.is_pi || '[:]' ||
             OLD.is_contact || '[:]' || OLD.is_beta_tester || '[:]' ||
             OLD.display_email || '[:]' || OLD.date_last_modified || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by  || '[:]' ||
	     coalesce(OLD.colleague_note,'') || '[:]' || coalesce(OLD.research_interest,'');

           PERFORM nex.insertdeletelog('COLLEAGUE'::text, OLD.colleague_id, v_row, USER);

      RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER colleague_audr
AFTER UPDATE OR DELETE ON nex.colleague FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_colleague_audr();

DROP TRIGGER IF EXISTS colleague_biur ON nex.colleague CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_colleague_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

    IF ((NEW.address1 IS NULL) AND (NEW.address2 IS NOT NULL)) THEN
        RAISE EXCEPTION 'Lines of address must be entered consecutively';
    END IF;

    IF ((NEW.address2 IS NULL) AND (NEW.address3 IS NOT NULL)) THEN
           RAISE EXCEPTION 'Lines of address must be entered consecutively';
    END IF;

    IF (NEW.postal_code IS NOT NULL) THEN
        NEW.postal_code := UPPER(NEW.postal_code);
    END IF;

     NEW.created_by := UPPER(NEW.created_by);
     PERFORM nex.checkuser(NEW.created_by);

     RETURN NEW;

  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.colleague_id != OLD.colleague_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF ((NEW.address1 IS NULL) AND (NEW.address2 IS NOT NULL)) THEN
        RAISE EXCEPTION 'Lines of address must be entered consecutively';
    END IF;

    IF ((NEW.address2 IS NULL) AND (NEW.address3 IS NOT NULL)) THEN
           RAISE EXCEPTION 'Lines of address must be entered consecutively';
    END IF;

    IF (NEW.postal_code IS NOT NULL) THEN
        NEW.postal_code := UPPER(NEW.postal_code);
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER colleague_biur
BEFORE INSERT OR UPDATE ON nex.colleague FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_colleague_biur();

DROP TRIGGER IF EXISTS colleaguerelation_audr ON nex.colleague_relation CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_colleaguerelation_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

     IF (OLD.source_id != NEW.source_id) THEN
       PERFORM nex.insertupdatelog('COLLEAGUE_RELATION'::text, 'SOURCE_ID'::text, OLD.relation_id, OLD.source_id::text, NEW.source_id::text, USER);
    END IF;

    IF (((OLD.bud_id IS NULL) AND (NEW.bud_id IS NOT NULL)) OR ((OLD.bud_id IS NOT NULL) AND (NEW.bud_id IS NULL)) OR (OLD.bud_id != NEW.bud_id)) THEN
       PERFORM nex.insertupdatelog('COLLEAGUE_RELATION'::text, 'BUD_ID'::text, OLD.relation_id, OLD.bud_id::text, NEW.bud_id::text, USER);
    END IF;

    IF (OLD.colleague_id != NEW.colleague_id) THEN
       PERFORM nex.insertupdatelog('COLLEAGUE_RELATION'::text, 'COLLEAGUE_ID'::text, OLD.relation_id, OLD.colleague_id::text, NEW.colleague_id::text, USER);
    END IF;

     IF (OLD.associate_id != NEW.associate_id) THEN
       PERFORM nex.insertupdatelog('COLLEAGUE_RELATION'::text, 'ASSOCIATE_ID'::text, OLD.relation_id, OLD.associate_id::text, NEW.associate_id::text, USER);
    END IF;

    IF (OLD.association_type != NEW.association_type) THEN
       PERFORM nex.insertupdatelog('COLLEAGUE_RELATION'::text, 'ASSOCIATION_TYPE'::text, OLD.relation_id, OLD.association_type, NEW.association_type, USER);
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.relation_id || '[:]' || OLD.source_id || '[:]' ||
             coalesce(OLD.bud_id,0) || '[:]' || OLD.colleague_id || '[:]' ||
             OLD.associate_id || '[:]' || OLD.association_type || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

            PERFORM nex.insertdeletelog('COLLEAGUE_RELATION'::text, OLD.relation_id, v_row, USER);

     RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER colleaguerelation_audr
AFTER UPDATE OR DELETE ON nex.colleague_relation FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_colleaguerelation_audr();

DROP TRIGGER IF EXISTS colleaguerelation_biur ON nex.colleague_relation CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_colleaguerelation_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := UPPER(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;

  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.relation_id != OLD.relation_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER colleaguerelation_biur
BEFORE INSERT OR UPDATE ON nex.colleague_relation FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_colleaguerelation_biur();

DROP TRIGGER IF EXISTS colleagueurl_audr ON nex.colleague_url CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_colleagueurl_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

    IF (OLD.display_name != NEW.display_name) THEN
       PERFORM nex.insertupdatelog('COLLEAGUE_URL'::text, 'DISPLAY_NAME'::text, OLD.url_id, OLD.display_name, NEW.display_name, USER);
    END IF;

    IF (OLD.obj_url != NEW.obj_url) THEN
       PERFORM nex.insertupdatelog('COLLEAGUE_URL'::text, 'OBJ_URL'::text, OLD.url_id, OLD.obj_url, NEW.obj_url, USER);
    END IF;

     IF (OLD.source_id != NEW.source_id) THEN
       PERFORM nex.insertupdatelog('COLLEAGUE_URL'::text, 'SOURCE_ID'::text, OLD.url_id, OLD.source_id::text, NEW.source_id::text, USER);
    END IF;

    IF (((OLD.bud_id IS NULL) AND (NEW.bud_id IS NOT NULL)) OR ((OLD.bud_id IS NOT NULL) AND (NEW.bud_id IS NULL)) OR (OLD.bud_id != NEW.bud_id)) THEN
       PERFORM nex.insertupdatelog('COLLEAGUE_URL'::text, 'BUD_ID'::text, OLD.url_id, OLD.bud_id::text, NEW.bud_id::text, USER);
    END IF;

    IF (OLD.colleague_id != NEW.colleague_id) THEN
       PERFORM nex.insertupdatelog('COLLEAGUE_URL'::text, 'COLLEAGUE_ID'::text, OLD.url_id, OLD.colleague_id::text, NEW.colleague_id::text, USER);
    END IF;

    IF (OLD.url_type != NEW.url_type) THEN
       PERFORM nex.insertupdatelog('COLLEAGUE_URL'::text, 'URL_TYPE'::text, OLD.url_id, OLD.url_type, NEW.url_type, USER);
    END IF;

    RETURN NEW;
    
  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.url_id || '[:]' ||
             OLD.display_name || '[:]' || OLD.obj_url || '[:]' ||
             OLD.source_id || '[:]' || coalesce(OLD.bud_id,0) || '[:]' ||
             OLD.colleague_id || '[:]' || OLD.url_type || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

            PERFORM nex.insertdeletelog('COLLEAGUE_URL'::text, OLD.url_id, v_row, USER);

     RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER colleagueurl_audr
AFTER UPDATE OR DELETE ON nex.colleague_url FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_colleagueurl_audr();

DROP TRIGGER IF EXISTS colleagueurl_biur ON nex.colleague_url CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_colleagueurl_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := UPPER(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;

  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.url_id != OLD.url_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER colleagueurl_biur
BEFORE INSERT OR UPDATE ON nex.colleague_url FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_colleagueurl_biur();

DROP TRIGGER IF EXISTS colleaguekeyword_audr ON nex.colleague_keyword CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_colleaguekeyword_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

    IF (OLD.colleague_id != NEW.colleague_id) THEN
       PERFORM nex.insertupdatelog('COLLEAGUE_KEYWORD'::text, 'COLLEAGUE_ID'::text, OLD.colleague_keyword_id, OLD.colleague_id::text, NEW.colleague_id::text, USER);
    END IF;

     IF (OLD.keyword_id != NEW.keyword_id) THEN
       PERFORM nex.insertupdatelog('COLLEAGUE_KEYWORD'::text, 'KEYWORD_ID'::text, OLD.colleague_keyword_id, OLD.keyword_id::text, NEW.keyword_id::text, USER);
    END IF;

     IF (OLD.source_id != NEW.source_id) THEN
       PERFORM nex.insertupdatelog('COLLEAGUE_KEYWORD'::text, 'SOURCE_ID'::text, OLD.colleague_keyword_id, OLD.source_id::text, NEW.source_id::text, USER);
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.colleague_keyword_id || '[:]' || OLD.colleague_id || '[:]' ||
             OLD.keyword_id || '[:]' || OLD.source_id || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

         PERFORM nex.insertdeletelog('COLLEAGUE_KEYWORD'::text, OLD.colleague_keyword_id, v_row, USER);

    RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER colleaguekeyword_audr
AFTER UPDATE OR DELETE ON nex.colleague_keyword FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_colleaguekeyword_audr();

DROP TRIGGER IF EXISTS colleaguekeyword_biur ON nex.colleague_keyword CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_colleaguekeyword_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := UPPER(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;

  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.colleague_keyword_id != OLD.colleague_keyword_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER colleaguekeyword_biur
BEFORE INSERT OR UPDATE ON nex.colleague_keyword FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_colleaguekeyword_biur();

DROP TRIGGER IF EXISTS colleaguelocus_audr ON nex.colleague_locus CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_colleaguelocus_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

    IF (OLD.colleague_id != NEW.colleague_id) THEN
       PERFORM nex.insertupdatelog('COLLEAGUE_LOCUS'::text, 'COLLEAGUE_ID'::text, OLD.colleague_locus_id, OLD.colleague_id::text, NEW.colleague_id::text, USER);
    END IF;

     IF (OLD.locus_id != NEW.locus_id) THEN
       PERFORM nex.insertupdatelog('COLLEAGUE_LOCUS'::text, 'LOCUS_ID'::text, OLD.colleague_locus_id, OLD.locus_id::text, NEW.locus_id::text, USER);
    END IF;

     IF (OLD.source_id != NEW.source_id) THEN
       PERFORM nex.insertupdatelog('COLLEAGUE_LOCUS'::text, 'SOURCE_ID'::text, OLD.colleague_locus_id, OLD.source_id::text, NEW.source_id::text, USER);
    END IF;

    RETURN NEW;
    
  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.colleague_locus_id || '[:]' || OLD.colleague_id || '[:]' ||
             OLD.locus_id || '[:]' || OLD.source_id || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

         PERFORM nex.insertdeletelog('COLLEAGUE_LOCUS'::text, OLD.colleague_locus_id, v_row, USER);

    RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER colleaguelocus_audr
AFTER UPDATE OR DELETE ON nex.colleague_locus FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_colleaguelocus_audr();

DROP TRIGGER IF EXISTS colleaguelocus_biur ON nex.colleague_locus CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_colleaguelocus_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := UPPER(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;

  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.colleague_locus_id != OLD.colleague_locus_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER colleaguelocus_biur
BEFORE INSERT OR UPDATE ON nex.colleague_locus FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_colleaguelocus_biur();

DROP TRIGGER IF EXISTS colleaguereference_audr ON nex.colleague_reference CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_colleaguereference_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

    IF (OLD.colleague_id != NEW.colleague_id) THEN
       PERFORM nex.insertupdatelog('COLLEAGUE_REFERENCE'::text, 'COLLEAGUE_ID'::text, OLD.colleague_reference_id, OLD.colleague_id::text, NEW.colleague_id::text, USER);
    END IF;

     IF (OLD.reference_id != NEW.reference_id) THEN
       PERFORM nex.insertupdatelog('COLLEAGUE_REFERENCE'::text, 'REFERENCE_ID'::text, OLD.colleague_reference_id, OLD.reference_id::text, NEW.reference_id::text, USER);
    END IF;

     IF (OLD.source_id != NEW.source_id) THEN
       PERFORM nex.insertupdatelog('COLLEAGUE_REFERENCE'::text, 'SOURCE_ID'::text, OLD.colleague_reference_id, OLD.source_id::text, NEW.source_id::text, USER);
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.colleague_reference_id || '[:]' || OLD.colleague_id || '[:]' ||
             OLD.reference_id || '[:]' || OLD.source_id || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

         PERFORM nex.insertdeletelog('COLLEAGUE_REFERENCE'::text, OLD.colleague_reference_id, v_row, USER);

    RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER colleaguereference_audr
AFTER UPDATE OR DELETE ON nex.colleague_reference FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_colleaguereference_audr();

DROP TRIGGER IF EXISTS colleaguereference_biur ON nex.colleague_reference CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_colleaguereference_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := UPPER(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;

  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.colleague_reference_id != OLD.colleague_reference_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER colleaguereference_biur
BEFORE INSERT OR UPDATE ON nex.colleague_reference FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_colleaguereference_biur();


DROP TRIGGER IF EXISTS contig_audr ON nex.contig CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_contig_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

    IF (OLD.format_name != NEW.format_name) THEN
       PERFORM nex.insertupdatelog('CONTIG'::text, 'FORMAT_NAME'::text, OLD.contig_id, OLD.format_name, NEW.format_name, USER);
    END IF;

    IF (OLD.display_name != NEW.display_name) THEN
       PERFORM nex.insertupdatelog('CONTIG'::text, 'DISPLAY_NAME'::text, OLD.contig_id, OLD.display_name, NEW.display_name, USER);
    END IF;

    IF (OLD.obj_url != NEW.obj_url) THEN
       PERFORM nex.insertupdatelog('CONTIG'::text, 'OBJ_URL'::text, OLD.contig_id, OLD.obj_url, NEW.obj_url, USER);
    END IF;

     IF (OLD.source_id != NEW.source_id) THEN
       PERFORM nex.insertupdatelog('CONTIG'::text, 'SOURCE_ID'::text, OLD.contig_id, OLD.source_id::text, NEW.source_id::text, USER);
    END IF;

     IF (OLD.taxonomy_id != NEW.taxonomy_id) THEN
       PERFORM nex.insertupdatelog('CONTIG'::text, 'TAXONOMY_ID'::text, OLD.contig_id, OLD.taxonomy_id::text, NEW.taxonomy_id::text, USER);
    END IF;

     IF (OLD.so_id != NEW.so_id) THEN
       PERFORM nex.insertupdatelog('CONTIG'::text, 'SO_ID'::text, OLD.contig_id, OLD.so_id::text, NEW.so_id::text, USER);
    END IF;

    IF (((OLD.centromere_start IS NULL) AND (NEW.centromere_start IS NOT NULL)) OR ((OLD.centromere_start IS NOT NULL) AND (NEW.centromere_start IS NULL)) OR (OLD.centromere_start != NEW.centromere_start)) THEN
       PERFORM nex.insertupdatelog('CONTIG'::text, 'CENTROMERE_START'::text, OLD.contig_id, OLD.centromere_start::text, NEW.centromere_start::text, USER);
    END IF;

    IF (((OLD.centromere_end IS NULL) AND (NEW.centromere_end IS NOT NULL)) OR ((OLD.centromere_end IS NOT NULL) AND (NEW.centromere_end IS NULL)) OR (OLD.centromere_end != NEW.centromere_end)) THEN
       PERFORM nex.insertupdatelog('CONTIG'::text, 'CENTROMERE_END'::text, OLD.contig_id, OLD.centromere_end::text, NEW.centromere_end::text, USER);
    END IF;

    IF (OLD.genbank_accession != NEW.genbank_accession) THEN
       PERFORM nex.insertupdatelog('CONTIG'::text, 'GENBANK_ACCESSION'::text, OLD.contig_id, OLD.genbank_accession, NEW.genbank_accession, USER);
    END IF;

    IF (((OLD.gi_number IS NULL) AND (NEW.gi_number IS NOT NULL)) OR ((OLD.gi_number IS NOT NULL) AND (NEW.gi_number IS NULL)) OR (OLD.gi_number != NEW.gi_number)) THEN
       PERFORM nex.insertupdatelog('CONTIG'::text, 'GI_NUMBER'::text, OLD.contig_id, OLD.gi_number, NEW.gi_number, USER);
    END IF;

    IF (((OLD.refseq_id IS NULL) AND (NEW.refseq_id IS NOT NULL)) OR ((OLD.refseq_id IS NOT NULL) AND (NEW.refseq_id IS NULL)) OR (OLD.refseq_id != NEW.refseq_id)) THEN
       PERFORM nex.insertupdatelog('CONTIG'::text, 'REFSEQ_ID'::text, OLD.contig_id, OLD.refseq_id, NEW.refseq_id, USER);
    END IF;

    IF (((OLD.reference_chromosome_id IS NULL) AND (NEW.reference_chromosome_id IS NOT NULL)) OR ((OLD.reference_chromosome_id IS NOT NULL) AND (NEW.reference_chromosome_id IS NULL)) OR (OLD.reference_chromosome_id != NEW.reference_chromosome_id)) THEN
       PERFORM nex.insertupdatelog('CONTIG'::text, 'REFERENCE_CHROMOSOME_ID'::text, OLD.contig_id, OLD.reference_chromosome_id::text, NEW.reference_chromosome_id::text, USER);
    END IF;

    IF (((OLD.reference_start IS NULL) AND (NEW.reference_start IS NOT NULL)) OR ((OLD.reference_start IS NOT NULL) AND (NEW.reference_start IS NULL)) OR (OLD.reference_start != NEW.reference_start)) THEN
       PERFORM nex.insertupdatelog('CONTIG'::text, 'REFERENCE_START'::text, OLD.contig_id, OLD.reference_start::text, NEW.reference_start::text, USER);
    END IF;

    IF (((OLD.reference_end IS NULL) AND (NEW.reference_end IS NOT NULL)) OR ((OLD.reference_end IS NOT NULL) AND (NEW.reference_end IS NULL)) OR (OLD.reference_end != NEW.reference_end)) THEN
       PERFORM nex.insertupdatelog('CONTIG'::text, 'REFERENCE_END'::text, OLD.contig_id, OLD.reference_end::text, NEW.reference_end::text, USER);
    END IF;

    IF (((OLD.reference_percent_identity IS NULL) AND (NEW.reference_percent_identity IS NOT NULL)) OR ((OLD.reference_percent_identity IS NOT NULL) AND (NEW.reference_percent_identity IS NULL)) OR (OLD.reference_percent_identity != NEW.reference_percent_identity)) THEN
       PERFORM nex.insertupdatelog('CONTIG'::text, 'REFERENCE_PERCENT_IDENTITY'::text, OLD.contig_id, OLD.reference_percent_identity::text, NEW.reference_percent_identity::text, USER);
    END IF;

    IF (((OLD.reference_alignment_length IS NULL) AND (NEW.reference_alignment_length IS NOT NULL)) OR ((OLD.reference_alignment_length IS NOT NULL) AND (NEW.reference_alignment_length IS NULL)) OR (OLD.reference_alignment_length != NEW.reference_alignment_length)) THEN
       PERFORM nex.insertupdatelog('CONTIG'::text, 'REFERENCE_ALIGNMENT_LENGTH'::text, OLD.contig_id, OLD.reference_alignment_length::text, NEW.reference_alignment_length::text, USER);
    END IF;

    IF (((OLD.seq_version IS NULL) AND (NEW.seq_version IS NOT NULL)) OR ((OLD.seq_version IS NOT NULL) AND (NEW.seq_version IS NULL)) OR (OLD.seq_version != NEW.seq_version)) THEN
       PERFORM nex.insertupdatelog('CONTIG'::text, 'SEQ_VERSION'::text, OLD.contig_id, OLD.seq_version::text, NEW.seq_version::text, USER);
    END IF;

    IF (((OLD.coord_version IS NULL) AND (NEW.coord_version IS NOT NULL)) OR ((OLD.coord_version IS NOT NULL) AND (NEW.coord_version IS NULL)) OR (OLD.coord_version != NEW.coord_version)) THEN
       PERFORM nex.insertupdatelog('CONTIG'::text, 'COORD_VERSION'::text, OLD.contig_id, OLD.coord_version::text, NEW.coord_version::text, USER);
    END IF;

    IF (((OLD.genomerelease_id IS NULL) AND (NEW.genomerelease_id IS NOT NULL)) OR ((OLD.genomerelease_id IS NOT NULL) AND (NEW.genomerelease_id IS NULL)) OR (OLD.genomerelease_id != NEW.genomerelease_id)) THEN
       PERFORM nex.insertupdatelog('CONTIG'::text, 'GENOMERELEASE_ID'::text, OLD.contig_id, OLD.genomerelease_id::text, NEW.genomerelease_id::text, USER);
    END IF;

    IF (OLD.file_header != NEW.file_header) THEN
       PERFORM nex.insertupdatelog('CONTIG'::text, 'FILE_HEADER'::text, OLD.contig_id, OLD.file_header, NEW.file_header, USER);
    END IF;

    IF (OLD.download_filename != NEW.download_filename) THEN
       PERFORM nex.insertupdatelog('CONTIG'::text, 'DOWNLOAD_FILENAME'::text, OLD.contig_id, OLD.download_filename, NEW.download_filename, USER);
    END IF;

    IF (((OLD.file_id IS NULL) AND (NEW.file_id IS NOT NULL)) OR ((OLD.file_id IS NOT NULL) AND (NEW.file_id IS NULL)) OR (OLD.file_id != NEW.file_id)) THEN
       PERFORM nex.insertupdatelog('CONTIG'::text, 'FILE_ID'::text, OLD.contig_id, OLD.file_id::text, NEW.file_id::text, USER);
    END IF;

     IF (OLD.residues != NEW.residues) THEN
       PERFORM nex.insertupdatelog('CONTIG'::text, 'RESIDUES'::text, OLD.contig_id, OLD.residues, NEW.residues, USER);
    END IF;

    RETURN NEW;
    
  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.contig_id || '[:]' || OLD.format_name || '[:]' ||
             OLD.display_name || '[:]' || OLD.obj_url || '[:]' ||
             OLD.source_id || '[:]' ||
             OLD.taxonomy_id || '[:]' || OLD.so_id || '[:]' ||
             coalesce(OLD.centromere_start,0) || '[:]' || coalesce(OLD.centromere_end,0) || '[:]' ||
             OLD.genbank_accession || '[:]' || coalesce(OLD.gi_number,'') || '[:]' ||
             coalesce(OLD.refseq_id,'') || '[:]' || coalesce(OLD.reference_chromosome_id,0) || '[:]' ||
             coalesce(OLD.reference_start,0) || '[:]' || coalesce(OLD.reference_end,0) || '[:]' ||
             coalesce(OLD.reference_percent_identity,0) || '[:]' || coalesce(OLD.reference_alignment_length,0) || '[:]' ||
             coalesce(OLD.seq_version,'') || '[:]' || coalesce(OLD.coord_version,'') || '[:]' ||
             coalesce(OLD.genomerelease_id,0) || '[:]' || OLD.file_header || '[:]' ||
             OLD.download_filename || '[:]' || coalesce(OLD.file_id,0) || '[:]' ||
             OLD.residues || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

          PERFORM nex.insertdeletelog('CONTIG'::text, OLD.contig_id, v_row, USER);

     RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER contig_audr
AFTER UPDATE OR DELETE ON nex.contig FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_contig_audr();

DROP TRIGGER IF EXISTS contig_biur ON nex.contig CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_contig_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := UPPER(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;

  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.contig_id != OLD.contig_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER contig_biur
BEFORE INSERT OR UPDATE ON nex.contig FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_contig_biur();

DROP TRIGGER IF EXISTS contigurl_audr ON nex.contig_url CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_contigurl_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

    IF (OLD.display_name != NEW.display_name) THEN
       PERFORM nex.insertupdatelog('CONTIG_URL'::text, 'DISPLAY_NAME'::text, OLD.url_id, OLD.display_name, NEW.display_name, USER);
    END IF;

    IF (OLD.obj_url != NEW.obj_url) THEN
       PERFORM nex.insertupdatelog('CONTIG_URL'::text, 'OBJ_URL'::text, OLD.url_id, OLD.obj_url, NEW.obj_url, USER);
    END IF;

     IF (OLD.source_id != NEW.source_id) THEN
       PERFORM nex.insertupdatelog('CONTIG_URL'::text, 'SOURCE_ID'::text, OLD.url_id, OLD.source_id::text, NEW.source_id::text, USER);
    END IF;

    IF (OLD.contig_id != NEW.contig_id) THEN
       PERFORM nex.insertupdatelog('CONTIG_URL'::text, 'CONTIG_ID'::text, OLD.url_id, OLD.contig_id::text, NEW.contig_id::text, USER);
    END IF;

    IF (OLD.url_type != NEW.url_type) THEN
       PERFORM nex.insertupdatelog('CONTIG_URL'::text, 'URL_TYPE'::text, OLD.url_id, OLD.url_type, NEW.url_type, USER);
    END IF;

    RETURN NEW;
    
  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.url_id || '[:]' || OLD.display_name || '[:]' ||
             OLD.obj_url || '[:]' || OLD.source_id || '[:]' || 
             OLD.contig_id || '[:]' || OLD.url_type || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

           PERFORM nex.insertdeletelog('CONTIG_URL'::text, OLD.url_id, v_row, USER);

      RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER contigurl_audr
AFTER UPDATE OR DELETE ON nex.contig_url FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_contigurl_audr();

DROP TRIGGER IF EXISTS contigurl_biur ON nex.contig_url CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_contigurl_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := UPPER(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;

  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.url_id != OLD.url_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER contigurl_biur
BEFORE INSERT OR UPDATE ON nex.contig_url FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_contigurl_biur();


DROP TRIGGER IF EXISTS dataset_audr ON nex.dataset CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_dataset_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

    IF (OLD.format_name != NEW.format_name) THEN
       PERFORM nex.insertupdatelog('DATASET'::text, 'FORMAT_NAME'::text, OLD.dataset_id, OLD.format_name, NEW.format_name, USER);
    END IF;

    IF (OLD.display_name != NEW.display_name) THEN
       PERFORM nex.insertupdatelog('DATASET'::text, 'DISPLAY_NAME'::text, OLD.dataset_id, OLD.display_name, NEW.display_name, USER);
    END IF;

    IF (OLD.obj_url != NEW.obj_url) THEN
       PERFORM nex.insertupdatelog('DATASET'::text, 'OBJ_URL'::text, OLD.dataset_id, OLD.obj_url, NEW.obj_url, USER);
    END IF;

     IF (OLD.source_id != NEW.source_id) THEN
       PERFORM nex.insertupdatelog('DATASET'::text, 'SOURCE_ID'::text, OLD.dataset_id, OLD.source_id::text, NEW.source_id::text, USER);
    END IF;

    IF (((OLD.dbxref_id IS NULL) AND (NEW.dbxref_id IS NOT NULL)) OR ((OLD.dbxref_id IS NOT NULL) AND (NEW.dbxref_id IS NULL)) OR (OLD.dbxref_id != NEW.dbxref_id)) THEN
       PERFORM nex.insertupdatelog('DATASET'::text, 'DBXREF_ID'::text, OLD.dataset_id, OLD.dbxref_id, NEW.dbxref_id, USER);
    END IF;

    IF (((OLD.dbxref_type IS NULL) AND (NEW.dbxref_type IS NOT NULL)) OR ((OLD.dbxref_type IS NOT NULL) AND (NEW.dbxref_type IS NULL)) OR (OLD.dbxref_type != NEW.dbxref_type)) THEN
       PERFORM nex.insertupdatelog('DATASET'::text, 'DBXREF_TYPE'::text, OLD.dataset_id, OLD.dbxref_type, NEW.dbxref_type, USER);
    END IF;

    IF (((OLD.date_public IS NULL) AND (NEW.date_public IS NOT NULL)) OR ((OLD.date_public IS NOT NULL) AND (NEW.date_public IS NULL)) OR (OLD.date_public != NEW.date_public)) THEN
       PERFORM nex.insertupdatelog('DATASET'::text, 'DATE_PUBLIC'::text, OLD.dataset_id, OLD.date_public::text, NEW.date_public::text, USER);
    END IF;

    IF (((OLD.parent_dataset_id IS NULL) AND (NEW.parent_dataset_id IS NOT NULL)) OR ((OLD.parent_dataset_id IS NOT NULL) AND (NEW.parent_dataset_id IS NULL)) OR (OLD.parent_dataset_id != NEW.parent_dataset_id)) THEN
       PERFORM nex.insertupdatelog('DATASET'::text, 'PARENT_DATASET_ID'::text, OLD.dataset_id, OLD.parent_dataset_id::text, NEW.parent_dataset_id::text, USER);
    END IF;

    IF (OLD.assay_id != NEW.assay_id) THEN
       PERFORM nex.insertupdatelog('DATASET'::text, 'ASSAY_ID'::text, OLD.dataset_id, OLD.assay_id::text, NEW.assay_id::text, USER);
    END IF;

    IF (((OLD.channel_count IS NULL) AND (NEW.channel_count IS NOT NULL)) OR ((OLD.channel_count IS NOT NULL) AND (NEW.channel_count IS NULL)) OR (OLD.channel_count != NEW.channel_count)) THEN
       PERFORM nex.insertupdatelog('DATASET'::text, 'CHANNEL_COUNT'::text, OLD.dataset_id, OLD.channel_count::text, NEW.channel_count::text, USER);
    END IF;

    IF (OLD.sample_count != NEW.sample_count) THEN
       PERFORM nex.insertupdatelog('DATASET'::text, 'SAMPLE_COUNT'::text, OLD.dataset_id, OLD.sample_count::text, NEW.sample_count::text, USER);
    END IF;

    IF (OLD.is_in_spell != NEW.is_in_spell) THEN
       PERFORM nex.insertupdatelog('DATASET'::text, 'IS_IN_SPELL'::text, OLD.dataset_id, OLD.is_in_spell::text, NEW.is_in_spell::text, USER);
    END IF;

    IF (OLD.is_in_browser != NEW.is_in_browser) THEN
       PERFORM nex.insertupdatelog('DATASET'::text, 'IS_IN_BROWSER'::text, OLD.dataset_id, OLD.is_in_browser::text, NEW.is_in_browser::text, USER);
    END IF;

    IF (((OLD.description IS NULL) AND (NEW.description IS NOT NULL)) OR ((OLD.description IS NOT NULL) AND (NEW.description IS NULL)) OR (OLD.description != NEW.description)) THEN
       PERFORM nex.insertupdatelog('DATASET'::text, 'DESCRIPTION'::text, OLD.dataset_id, OLD.description, NEW.description, USER);
    END IF;

    RETURN NEW;
    
  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.dataset_id || '[:]' || OLD.format_name || '[:]' ||
	     OLD.display_name || '[:]' || OLD.obj_url || '[:]' ||
         OLD.source_id || '[:]' || coalesce(OLD.dbxref_id,'') || '[:]' ||
	     coalesce(OLD.dbxref_type,'') || '[:]' || coalesce(OLD.date_public,'1000-01-01') || '[:]' ||
	     coalesce(OLD.parent_dataset_id,0) || '[:]' || OLD.assay_id || '[:]' ||
         coalesce(OLD.channel_count,0) || '[:]' || OLD.sample_count || '[:]' ||
         OLD.is_in_spell || '[:]' || OLD.is_in_browser || '[:]' ||
         coalesce(OLD.description,'') || '[:]' ||
         OLD.date_created || '[:]' || OLD.created_by;

         PERFORM nex.insertdeletelog('DATASET'::text, OLD.dataset_id, v_row, USER);

    RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER dataset_audr
AFTER UPDATE OR DELETE ON nex.dataset FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_dataset_audr();

DROP TRIGGER IF EXISTS dataset_biur ON nex.dataset CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_dataset_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := UPPER(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;

  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.dataset_id != OLD.dataset_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER dataset_biur
BEFORE INSERT OR UPDATE ON nex.dataset FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_dataset_biur();

DROP TRIGGER IF EXISTS datasetlab_audr ON nex.datasetlab CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_datasetlab_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

    IF (OLD.dataset_id != NEW.dataset_id) THEN
       PERFORM nex.insertupdatelog('DATASETLAB'::text, 'DATASET_ID'::text, OLD.datasetlab_id, OLD.dataset_id::text, NEW.dataset_id::text, USER);
    END IF;

     IF (OLD.source_id != NEW.source_id) THEN
       PERFORM nex.insertupdatelog('DATASETLAB'::text, 'SOURCE_ID'::text, OLD.datasetlab_id, OLD.source_id::text, NEW.source_id::text, USER);
    END IF;

     IF (OLD.lab_name != NEW.lab_name) THEN
       PERFORM nex.insertupdatelog('DATASETLAB'::text, 'LAB_NAME'::text, OLD.datasetlab_id, OLD.lab_name, NEW.lab_name, USER);
    END IF;

     IF (OLD.lab_location != NEW.lab_location) THEN
       PERFORM nex.insertupdatelog('DATASETLAB'::text, 'LAB_LOCATION'::text, OLD.datasetlab_id, OLD.lab_location, NEW.lab_location, USER);
    END IF;

    IF (((OLD.colleague_id IS NULL) AND (NEW.colleague_id IS NOT NULL)) OR ((OLD.colleague_id IS NOT NULL) AND (NEW.colleague_id IS NULL)) OR (OLD.colleague_id != NEW.colleague_id)) THEN
       PERFORM nex.insertupdatelog('DATASET'::text, 'COLLEAGUE_ID'::text, OLD.dataset_id, OLD.colleague_id::text, NEW.colleague_id::text, USER);
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.datasetlab_id || '[:]' || OLD.dataset_id || '[:]' ||
             OLD.source_id || '[:]' ||  OLD.lab_name || '[:]' ||
             OLD.lab_location || '[:]' || coalesce(OLD.colleague_id,0) || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

          PERFORM nex.insertdeletelog('DATASETLAB'::text, OLD.datasetlab_id, v_row, USER);

     RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER datasetlab_audr
AFTER UPDATE OR DELETE ON nex.datasetlab FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_datasetlab_audr();

DROP TRIGGER IF EXISTS datasetlab_biur ON nex.datasetlab CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_datasetlab_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := UPPER(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;

  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.datasetlab_id != OLD.datasetlab_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER datasetlab_biur
BEFORE INSERT OR UPDATE ON nex.datasetlab FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_datasetlab_biur();

DROP TRIGGER IF EXISTS dataseturl_audr ON nex.dataset_url CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_dataseturl_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

    IF (OLD.display_name != NEW.display_name) THEN
       PERFORM nex.insertupdatelog('DATASET_URL'::text, 'DISPLAY_NAME'::text, OLD.url_id, OLD.display_name, NEW.display_name, USER);
    END IF;

    IF (OLD.obj_url != NEW.obj_url) THEN
       PERFORM nex.insertupdatelog('DATASET_URL'::text, 'OBJ_URL'::text, OLD.url_id, OLD.obj_url, NEW.obj_url, USER);
    END IF;

     IF (OLD.source_id != NEW.source_id) THEN
       PERFORM nex.insertupdatelog('DATASET_URL'::text, 'SOURCE_ID'::text, OLD.url_id, OLD.source_id::text, NEW.source_id::text, USER);
    END IF;

    IF (OLD.dataset_id != NEW.dataset_id) THEN
       PERFORM nex.insertupdatelog('DATASET_URL'::text, 'DATASET_ID'::text, OLD.url_id, OLD.dataset_id::text, NEW.dataset_id::text, USER);
    END IF;

    IF (OLD.url_type != NEW.url_type) THEN
       PERFORM nex.insertupdatelog('DATASET_URL'::text, 'URL_TYPE'::text, OLD.url_id, OLD.url_type, NEW.url_type, USER);
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.url_id || '[:]' || OLD.display_name || '[:]' ||
             OLD.obj_url || '[:]' || OLD.source_id || '[:]' || 
             OLD.dataset_id || '[:]' || OLD.url_type || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

           PERFORM nex.insertdeletelog('DATASET_URL'::text, OLD.url_id, v_row, USER);

     RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER dataseturl_audr
AFTER UPDATE OR DELETE ON nex.dataset_url FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_dataseturl_audr();

DROP TRIGGER IF EXISTS dataseturl_biur ON nex.dataset_url CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_dataseturl_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := UPPER(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;

  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.url_id != OLD.url_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;
    
    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER dataseturl_biur
BEFORE INSERT OR UPDATE ON nex.dataset_url FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_dataseturl_biur();

DROP TRIGGER IF EXISTS datasetfile_audr ON nex.dataset_file CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_datasetfile_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

    IF (OLD.file_id != NEW.file_id) THEN
       PERFORM nex.insertupdatelog('DATASET_FILE'::text, 'FILE_ID'::text, OLD.dataset_file_id, OLD.file_id::text, NEW.file_id::text, USER);
    END IF;

     IF (OLD.dataset_id != NEW.dataset_id) THEN
       PERFORM nex.insertupdatelog('DATASET_FILE'::text, 'DATASET_ID'::text, OLD.dataset_file_id, OLD.dataset_id::text, NEW.dataset_id::text, USER);
    END IF;

     IF (OLD.source_id != NEW.source_id) THEN
       PERFORM nex.insertupdatelog('DATASET_FILE'::text, 'SOURCE_ID'::text, OLD.dataset_file_id, OLD.source_id::text, NEW.source_id::text, USER);
    END IF;

    RETURN NEW;
    
  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.dataset_file_id || '[:]' || OLD.file_id || '[:]' ||
             OLD.dataset_id || '[:]' || OLD.source_id || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

         PERFORM nex.insertdeletelog('DATASET_FILE'::text, OLD.dataset_file_id, v_row, USER);

     RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER datasetfile_audr
AFTER UPDATE OR DELETE ON nex.dataset_file FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_datasetfile_audr();

DROP TRIGGER IF EXISTS datasetfile_biur ON nex.dataset_file CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_datasetfile_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := UPPER(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;
       
  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.dataset_file_id != OLD.dataset_file_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER datasetfile_biur
BEFORE INSERT OR UPDATE ON nex.dataset_file FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_datasetfile_biur();

DROP TRIGGER IF EXISTS datasetkeyword_audr ON nex.dataset_keyword CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_datasetkeyword_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

    IF (OLD.dataset_id != NEW.dataset_id) THEN
       PERFORM nex.insertupdatelog('DATASET_KEYWORD'::text, 'DATASET_ID'::text, OLD.dataset_keyword_id, OLD.dataset_id::text, NEW.dataset_id::text, USER);
    END IF;

     IF (OLD.keyword_id != NEW.keyword_id) THEN
       PERFORM nex.insertupdatelog('DATASET_KEYWORD'::text, 'KEYWORD_ID'::text, OLD.dataset_keyword_id, OLD.keyword_id::text, NEW.keyword_id::text, USER);
    END IF;

     IF (OLD.source_id != NEW.source_id) THEN
       PERFORM nex.insertupdatelog('DATASET_KEYWORD'::text, 'SOURCE_ID'::text, OLD.dataset_keyword_id, OLD.source_id::text, NEW.source_id::text, USER);
    END IF;

    RETURN NEW;
    
  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.dataset_keyword_id || '[:]' || OLD.keyword_id || '[:]' ||
             OLD.dataset_id || '[:]' || OLD.source_id || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

         PERFORM nex.insertdeletelog('DATASET_KEYWORD'::text, OLD.dataset_keyword_id, v_row, USER);

     RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER datasetkeyword_audr
AFTER UPDATE OR DELETE ON nex.dataset_keyword FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_datasetkeyword_audr();

DROP TRIGGER IF EXISTS datasetkeyword_biur ON nex.dataset_keyword CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_datasetkeyword_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := UPPER(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;

  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.dataset_keyword_id != OLD.dataset_keyword_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER datasetkeyword_biur
BEFORE INSERT OR UPDATE ON nex.dataset_keyword FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_datasetkeyword_biur();

DROP TRIGGER IF EXISTS datasetreference_audr ON nex.dataset_reference CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_datasetreference_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

    IF (OLD.dataset_id != NEW.dataset_id) THEN
       PERFORM nex.insertupdatelog('DATASET_REFERENCE'::text, 'DATASET_ID'::text, OLD.dataset_reference_id, OLD.dataset_id::text, NEW.dataset_id::text, USER);
    END IF;

     IF (OLD.reference_id != NEW.reference_id) THEN
       PERFORM nex.insertupdatelog('DATASET_REFERENCE'::text, 'REFERENCE_ID'::text, OLD.dataset_reference_id, OLD.reference_id::text, NEW.reference_id::text, USER);
    END IF;

     IF (OLD.source_id != NEW.source_id) THEN
       PERFORM nex.insertupdatelog('DATASET_REFERENCE'::text, 'SOURCE_ID'::text, OLD.dataset_reference_id, OLD.source_id::text, NEW.source_id::text, USER);
    END IF;

    RETURN NEW;
    
  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.dataset_reference_id || '[:]' || OLD.reference_id || '[:]' ||
             OLD.dataset_id || '[:]' || OLD.source_id || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

          PERFORM nex.insertdeletelog('DATASET_REFERENCE'::text, OLD.dataset_reference_id, v_row, USER);

    RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER datasetreference_audr
AFTER UPDATE OR DELETE ON nex.dataset_reference FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_datasetreference_audr();

DROP TRIGGER IF EXISTS datasetreference_biur ON nex.dataset_reference CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_datasetreference_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := UPPER(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;

  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.dataset_reference_id != OLD.dataset_reference_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER datasetreference_biur
BEFORE INSERT OR UPDATE ON nex.dataset_reference FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_datasetreference_biur();

DROP TRIGGER IF EXISTS datasetsample_audr ON nex.datasetsample CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_datasetsample_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

    IF (OLD.format_name != NEW.format_name) THEN
       PERFORM nex.insertupdatelog('DATASETSAMPLE'::text, 'FORMAT_NAME'::text, OLD.datasetsample_id, OLD.format_name, NEW.format_name, USER);
    END IF;

    IF (OLD.display_name != NEW.display_name) THEN
       PERFORM nex.insertupdatelog('DATASETSAMPLE'::text, 'DISPLAY_NAME'::text, OLD.datasetsample_id, OLD.display_name, NEW.display_name, USER);
    END IF;

    IF (OLD.obj_url != NEW.obj_url) THEN
       PERFORM nex.insertupdatelog('DATASETSAMPLE'::text, 'OBJ_URL'::text, OLD.datasetsample_id, OLD.obj_url, NEW.obj_url, USER);
    END IF;

     IF (OLD.source_id != NEW.source_id) THEN
       PERFORM nex.insertupdatelog('DATASETSAMPLE'::text, 'SOURCE_ID'::text, OLD.datasetsample_id, OLD.source_id::text, NEW.source_id::text, USER);
    END IF;

    IF (((OLD.taxonomy_id IS NULL) AND (NEW.taxonomy_id IS NOT NULL)) OR ((OLD.taxonomy_id IS NOT NULL) AND (NEW.taxonomy_id IS NULL)) OR (OLD.taxonomy_id != NEW.taxonomy_id)) THEN
       PERFORM nex.insertupdatelog('DATASETSAMPLE'::text, 'TAXONOMY_ID'::text, OLD.datasetsample_id, OLD.taxonomy_id::text, NEW.taxonomy_id::text, USER);
    END IF;

    IF (OLD.dataset_id != NEW.dataset_id) THEN
       PERFORM nex.insertupdatelog('DATASETSAMPLE'::text, 'DATASET_ID'::text, OLD.datasetsample_id, OLD.dataset_id::text, NEW.dataset_id::text, USER);
    END IF;

    IF (OLD.sample_order != NEW.sample_order) THEN
       PERFORM nex.insertupdatelog('DATASETSAMPLE'::text, 'SAMPLE_ORDER'::text, OLD.datasetsample_id, OLD.sample_order::text, NEW.sample_order::text, USER);
    END IF;

    IF (((OLD.dbxref_id IS NULL) AND (NEW.dbxref_id IS NOT NULL)) OR ((OLD.dbxref_id IS NOT NULL) AND (NEW.dbxref_id IS NULL)) OR (OLD.dbxref_id != NEW.dbxref_id)) THEN
       PERFORM nex.insertupdatelog('DATASETSAMPLE'::text, 'DBXREF_ID'::text, OLD.datasetsample_id, OLD.dbxref_id, NEW.dbxref_id, USER);
    END IF;

    IF (((OLD.dbxref_type IS NULL) AND (NEW.dbxref_type IS NOT NULL)) OR ((OLD.dbxref_type IS NOT NULL) AND (NEW.dbxref_type IS NULL)) OR (OLD.dbxref_type != NEW.dbxref_type)) THEN
       PERFORM nex.insertupdatelog('DATASETSAMPLE'::text, 'DBXREF_TYPE'::text, OLD.datasetsample_id, OLD.dbxref_type, NEW.dbxref_type, USER);
    END IF;

    IF (((OLD.dbxref_url IS NULL) AND (NEW.dbxref_url IS NOT NULL)) OR ((OLD.dbxref_url IS NOT NULL) AND (NEW.dbxref_url IS NULL)) OR (OLD.dbxref_url != NEW.dbxref_url)) THEN
       PERFORM nex.insertupdatelog('DATASETSAMPLE'::text, 'DBXREF_URL'::text, OLD.datasetsample_id, OLD.dbxref_url, NEW.dbxref_url, USER);
    END IF;

    IF (((OLD.biosample IS NULL) AND (NEW.biosample IS NOT NULL)) OR ((OLD.biosample IS NOT NULL) AND (NEW.biosample IS NULL)) OR (OLD.biosample != NEW.biosample)) THEN
       PERFORM nex.insertupdatelog('DATASETSAMPLE'::text, 'BIOSAMPLE'::text, OLD.datasetsample_id, OLD.biosample, NEW.biosample, USER);
    END IF;

    IF (((OLD.strain_name IS NULL) AND (NEW.strain_name IS NOT NULL)) OR ((OLD.strain_name IS NOT NULL) AND (NEW.strain_name IS NULL)) OR (OLD.strain_name != NEW.strain_name)) THEN
       PERFORM nex.insertupdatelog('DATASETSAMPLE'::text, 'STRAIN_NAME'::text, OLD.datasetsample_id, OLD.strain_name, NEW.strain_name, USER);
    END IF;

    IF (((OLD.description IS NULL) AND (NEW.description IS NOT NULL)) OR ((OLD.description IS NOT NULL) AND (NEW.description IS NULL)) OR (OLD.description != NEW.description)) THEN
       PERFORM nex.insertupdatelog('DATASETSAMPLE'::text, 'DESCRIPTION'::text, OLD.datasetsample_id, OLD.description, NEW.description, USER);
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.datasetsample_id || '[:]' || OLD.format_name || '[:]' ||
	     OLD.display_name || '[:]' || OLD.obj_url || '[:]' ||
             OLD.source_id || '[:]' || coalesce(OLD.taxonomy_id,0) || '[:]' ||
             OLD.dataset_id || '[:]' || OLD.sample_order || '[:]' ||
             coalesce(OLD.dbxref_id,'') || '[:]' || coalesce(OLD.dbxref_type,'') || '[:]' ||
             coalesce(OLD.dbxref_url,'') || '[:]' || coalesce(OLD.biosample,'') || '[:]' || 
             coalesce(OLD.strain_name,'') || '[:]' || coalesce(OLD.description,'') || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

           PERFORM nex.insertdeletelog('DATASETSAMPLE'::text, OLD.datasetsample_id, v_row, USER);

     RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER datasetsample_audr
AFTER UPDATE OR DELETE ON nex.datasetsample FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_datasetsample_audr();

DROP TRIGGER IF EXISTS datasetsample_biur ON nex.datasetsample CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_datasetsample_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := UPPER(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;
       
  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.datasetsample_id != OLD.datasetsample_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER datasetsample_biur
BEFORE INSERT OR UPDATE ON nex.datasetsample FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_datasetsample_biur();

DROP TRIGGER IF EXISTS datasettrack_audr ON nex.datasettrack CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_datasettrack_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

    IF (OLD.format_name != NEW.format_name) THEN
       PERFORM nex.insertupdatelog('DATASETTRACK'::text, 'FORMAT_NAME'::text, OLD.datasettrack_id, OLD.format_name, NEW.format_name, USER);
    END IF;

    IF (OLD.display_name != NEW.display_name) THEN
       PERFORM nex.insertupdatelog('DATASETTRACK'::text, 'DISPLAY_NAME'::text, OLD.datasettrack_id, OLD.display_name, NEW.display_name, USER);
    END IF;

    IF (((OLD.obj_url IS NULL) AND (NEW.obj_url IS NOT NULL)) OR ((OLD.obj_url IS NOT NULL) AND (NEW.obj_url IS NULL)) OR (OLD.obj_url != NEW.obj_url)) THEN
       PERFORM nex.insertupdatelog('DATASET'::text, 'OBJ_URL'::text, OLD.dataset_id, OLD.obj_url, NEW.obj_url, USER);
    END IF;

     IF (OLD.source_id != NEW.source_id) THEN
       PERFORM nex.insertupdatelog('DATASETTRACK'::text, 'SOURCE_ID'::text, OLD.datasettrack_id, OLD.source_id::text, NEW.source_id::text, USER);
    END IF;

    IF (OLD.dataset_id != NEW.dataset_id) THEN
       PERFORM nex.insertupdatelog('DATASETTRACK'::text, 'DATASET_ID'::text, OLD.datasettrack_id, OLD.dataset_id::text, NEW.dataset_id::text, USER);
    END IF;

    IF (OLD.track_order != NEW.track_order) THEN
       PERFORM nex.insertupdatelog('DATASETTRACK'::text, 'TRACK_ORDER'::text, OLD.datasettrack_id, OLD.track_order::text, NEW.track_order::text, USER);
    END IF;

    RETURN NEW;
    
  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.datasettrack_id || '[:]' || OLD.format_name || '[:]' ||
             OLD.display_name || '[:]' || coalesce(OLD.obj_url,'') || '[:]' ||
             OLD.source_id || '[:]' || OLD.dataset_id || '[:]' ||
             OLD.track_order || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

           PERFORM nex.insertdeletelog('DATASETTRACK'::text, OLD.datasettrack_id, v_row, USER);

     RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER datasettrack_audr
AFTER UPDATE OR DELETE ON nex.datasettrack FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_datasettrack_audr();

DROP TRIGGER IF EXISTS datasettrack_biur ON nex.datasettrack CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_datasettrack_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := UPPER(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;

  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.datasettrack_id != OLD.datasettrack_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER datasettrack_biur
BEFORE INSERT OR UPDATE ON nex.datasettrack FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_datasettrack_biur();


DROP TRIGGER IF EXISTS diseasesubset_audr ON nex.diseasesubset CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_diseasesubset_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

    IF (OLD.format_name != NEW.format_name) THEN
       PERFORM nex.insertupdatelog('DISEASESUBSET'::text, 'FORMAT_NAME'::text, OLD.diseasesubset_id, OLD.format_name, NEW.format_name, USER);
    END IF;

    IF (OLD.display_name != NEW.display_name) THEN
       PERFORM nex.insertupdatelog('DISEASESUBSET'::text, 'DISPLAY_NAME'::text, OLD.diseasesubset_id, OLD.display_name, NEW.display_name, USER);
    END IF;

    IF (OLD.obj_url != NEW.obj_url) THEN
       PERFORM nex.insertupdatelog('DISEASESUBSET'::text, 'OBJ_URL'::text, OLD.diseasesubset_id, OLD.obj_url, NEW.obj_url, USER);
    END IF;

     IF (OLD.source_id != NEW.source_id) THEN
       PERFORM nex.insertupdatelog('DISEASESUBSET'::text, 'SOURCE_ID'::text, OLD.diseasesubset_id, OLD.source_id::text, NEW.source_id::text, USER);
    END IF;

     IF (OLD.disease_id != NEW.disease_id) THEN
       PERFORM nex.insertupdatelog('DISEASESUBSET'::text, 'DISEASE_ID'::text, OLD.diseasesubset_id, OLD.disease_id::text, NEW.disease_id::text, USER);
    END IF;

     IF (OLD.subset_name != NEW.subset_name) THEN
       PERFORM nex.insertupdatelog('DISEASESUBSET'::text, 'SUBSET_NAME'::text, OLD.diseasesubset_id, OLD.subset_name, NEW.subset_name, USER);
    END IF;

     IF (OLD.genome_count != NEW.genome_count) THEN
       PERFORM nex.insertupdatelog('DISEASESUBSET'::text, 'GENOME_COUNT'::text, OLD.diseasesubset_id, OLD.genome_count::text, NEW.genome_count::text, USER);
    END IF;

    IF (((OLD.description IS NULL) AND (NEW.description IS NOT NULL)) OR ((OLD.description IS NOT NULL) AND (NEW.description IS NULL)) OR (OLD.description != NEW.description)) THEN
       PERFORM nex.insertupdatelog('DISEASESUBSET'::text, 'DESCRIPTION'::text, OLD.diseasesubset_id, OLD.description, NEW.description, USER);
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.diseasesubset_id || '[:]' || OLD.format_name || '[:]' ||
	     OLD.display_name || '[:]' || OLD.obj_url || '[:]' ||
             OLD.source_id || '[:]' || 
             OLD.disease_id || '[:]' || OLD.subset_name || '[:]' ||
             OLD.genome_count || '[:]' || coalesce(OLD.description,'') || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

          PERFORM nex.insertdeletelog('DISEASESUBSET'::text, OLD.diseasesubset_id, v_row, USER);

     RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER diseasesubset_audr
AFTER UPDATE OR DELETE ON nex.diseasesubset FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_diseasesubset_audr();

DROP TRIGGER IF EXISTS diseasesubset_biur ON nex.diseasesubset CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_diseasesubset_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := UPPER(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;

  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.diseasesubset_id != OLD.diseasesubset_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER diseasesubset_biur
BEFORE INSERT OR UPDATE ON nex.diseasesubset FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_diseasesubset_biur();


DROP TRIGGER IF EXISTS genomerelease_audr ON nex.genomerelease CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_genomerelease_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

    IF (OLD.format_name != NEW.format_name) THEN
       PERFORM nex.insertupdatelog('GENOMERELEASE'::text, 'FORMAT_NAME'::text, OLD.genomerelease_id, OLD.format_name, NEW.format_name, USER);
    END IF;

    IF (OLD.display_name != NEW.display_name) THEN
       PERFORM nex.insertupdatelog('GENOMERELEASE'::text, 'DISPLAY_NAME'::text, OLD.genomerelease_id, OLD.display_name, NEW.display_name, USER);
    END IF;

    IF (OLD.obj_url != NEW.obj_url) THEN
       PERFORM nex.insertupdatelog('GENOMERELEASE'::text, 'OBJ_URL'::text, OLD.genomerelease_id, OLD.obj_url, NEW.obj_url, USER);
    END IF;

     IF (OLD.source_id != NEW.source_id) THEN
       PERFORM nex.insertupdatelog('GENOMERELEASE'::text, 'SOURCE_ID'::text, OLD.genomerelease_id, OLD.source_id::text, NEW.source_id::text, USER);
    END IF;

    IF (((OLD.file_id IS NULL) AND (NEW.file_id IS NOT NULL)) OR ((OLD.file_id IS NOT NULL) AND (NEW.file_id IS NULL)) OR (OLD.file_id != NEW.file_id)) THEN
       PERFORM nex.insertupdatelog('GENOMERELEASE'::text, 'FILE_ID'::text, OLD.genomerelease_id, OLD.file_id::text, NEW.file_id::text, USER);
    END IF;

     IF (OLD.sequence_release != NEW.sequence_release) THEN
       PERFORM nex.insertupdatelog('GENOMERELEASE'::text, 'SEQUENCE_RELEASE'::text, OLD.genomerelease_id, OLD.sequence_release::text, NEW.sequence_release::text, USER);
    END IF;

     IF (OLD.annotation_release != NEW.annotation_release) THEN
       PERFORM nex.insertupdatelog('GENOMERELEASE'::text, 'ANNOTATION_RELEASE'::text, OLD.genomerelease_id, OLD.annotation_release::text, NEW.annotation_release::text, USER);
    END IF;

     IF (OLD.curation_release != NEW.curation_release) THEN
       PERFORM nex.insertupdatelog('GENOMERELEASE'::text, 'CURATION_RELEASE'::text, OLD.genomerelease_id, OLD.curation_release::text, NEW.curation_release::text, USER);
    END IF;

     IF (OLD.release_date != NEW.release_date) THEN
       PERFORM nex.insertupdatelog('GENOMERELEASE'::text, 'RELEASE_DATE'::text, OLD.genomerelease_id, OLD.release_date::text, NEW.release_date::text, USER);
    END IF;

    IF (((OLD.description IS NULL) AND (NEW.description IS NOT NULL)) OR ((OLD.description IS NOT NULL) AND (NEW.description IS NULL)) OR (OLD.description != NEW.description)) THEN
       PERFORM nex.insertupdatelog('GENOMERELEASE'::text, 'DESCRIPTION'::text, OLD.genomerelease_id, OLD.description, NEW.description, USER);
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.genomerelease_id || '[:]' || OLD.format_name || '[:]' ||
             OLD.display_name || '[:]' || OLD.obj_url || '[:]' ||
             OLD.source_id || '[:]' ||  coalesce(OLD.file_id,0) || '[:]' ||
             OLD.sequence_release || '[:]' || OLD.annotation_release || '[:]' ||
             OLD.curation_release || '[:]' || OLD.release_date || '[:]' ||
             coalesce(OLD.description,'') || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

          PERFORM nex.insertdeletelog('GENOMERELEASE'::text, OLD.genomerelease_id, v_row, USER);

     RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER genomerelease_audr
AFTER UPDATE OR DELETE ON nex.genomerelease FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_genomerelease_audr();

DROP TRIGGER IF EXISTS genomerelease_biur ON nex.genomerelease CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_genomerelease_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := UPPER(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;

  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.genomerelease_id != OLD.genomerelease_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER genomerelease_biur
BEFORE INSERT OR UPDATE ON nex.genomerelease FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_genomerelease_biur();


DROP TRIGGER IF EXISTS goslim_audr ON nex.goslim CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_goslim_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

    IF (OLD.format_name != NEW.format_name) THEN
       PERFORM nex.insertupdatelog('GOSLIM'::text, 'FORMAT_NAME'::text, OLD.goslim_id, OLD.format_name, NEW.format_name, USER);
    END IF;

    IF (OLD.display_name != NEW.display_name) THEN
       PERFORM nex.insertupdatelog('GOSLIM'::text, 'DISPLAY_NAME'::text, OLD.goslim_id, OLD.display_name, NEW.display_name, USER);
    END IF;

    IF (OLD.obj_url != NEW.obj_url) THEN
       PERFORM nex.insertupdatelog('GOSLIM'::text, 'OBJ_URL'::text, OLD.goslim_id, OLD.obj_url, NEW.obj_url, USER);
    END IF;

     IF (OLD.source_id != NEW.source_id) THEN
       PERFORM nex.insertupdatelog('GOSLIM'::text, 'SOURCE_ID'::text, OLD.goslim_id, OLD.source_id::text, NEW.source_id::text, USER);
    END IF;

    IF (((OLD.bud_id IS NULL) AND (NEW.bud_id IS NOT NULL)) OR ((OLD.bud_id IS NOT NULL) AND (NEW.bud_id IS NULL)) OR (OLD.bud_id != NEW.bud_id)) THEN
       PERFORM nex.insertupdatelog('GOSLIM'::text, 'BUD_ID'::text, OLD.goslim_id, OLD.bud_id::text, NEW.bud_id::text, USER);
    END IF;

     IF (OLD.go_id != NEW.go_id) THEN
       PERFORM nex.insertupdatelog('GOSLIM'::text, 'GO_ID'::text, OLD.goslim_id, OLD.go_id::text, NEW.go_id::text, USER);
    END IF;

     IF (OLD.slim_name != NEW.slim_name) THEN
       PERFORM nex.insertupdatelog('GOSLIM'::text, 'SLIM_NAME'::text, OLD.goslim_id, OLD.slim_name, NEW.slim_name, USER);
    END IF;

     IF (OLD.genome_count != NEW.genome_count) THEN
       PERFORM nex.insertupdatelog('GOSLIM'::text, 'GENOME_COUNT'::text, OLD.goslim_id, OLD.genome_count::text, NEW.genome_count::text, USER);
    END IF;

    IF (((OLD.description IS NULL) AND (NEW.description IS NOT NULL)) OR ((OLD.description IS NOT NULL) AND (NEW.description IS NULL)) OR (OLD.description != NEW.description)) THEN
       PERFORM nex.insertupdatelog('GOSLIM'::text, 'DESCRIPTION'::text, OLD.goslim_id, OLD.description, NEW.description, USER);
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.goslim_id || '[:]' || OLD.format_name || '[:]' ||
	     OLD.display_name || '[:]' || OLD.obj_url || '[:]' ||
             OLD.source_id || '[:]' || coalesce(OLD.bud_id,0) || '[:]' ||
             OLD.go_id || '[:]' || OLD.slim_name || '[:]' ||
             OLD.genome_count || '[:]' || coalesce(OLD.description,'') || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

          PERFORM nex.insertdeletelog('GOSLIM'::text, OLD.goslim_id, v_row, USER);

      RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER goslim_audr
AFTER UPDATE OR DELETE ON nex.goslim FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_goslim_audr();

DROP TRIGGER IF EXISTS goslim_biur ON nex.goslim CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_goslim_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := UPPER(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;

  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.goslim_id != OLD.goslim_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER goslim_biur
BEFORE INSERT OR UPDATE ON nex.goslim FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_goslim_biur();


DROP TRIGGER IF EXISTS phenotype_audr ON nex.phenotype CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_phenotype_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

    IF (OLD.format_name != NEW.format_name) THEN
       PERFORM nex.insertupdatelog('PHENOTYPE'::text, 'FORMAT_NAME'::text, OLD.phenotype_id, OLD.format_name, NEW.format_name, USER);
    END IF;

    IF (OLD.display_name != NEW.display_name) THEN
       PERFORM nex.insertupdatelog('PHENOTYPE'::text, 'DISPLAY_NAME'::text, OLD.phenotype_id, OLD.display_name, NEW.display_name, USER);
    END IF;

    IF (OLD.obj_url != NEW.obj_url) THEN
       PERFORM nex.insertupdatelog('PHENOTYPE'::text, 'OBJ_URL'::text, OLD.phenotype_id, OLD.obj_url, NEW.obj_url, USER);
    END IF;

     IF (OLD.source_id != NEW.source_id) THEN
       PERFORM nex.insertupdatelog('PHENOTYPE'::text, 'SOURCE_ID'::text, OLD.phenotype_id, OLD.source_id::text, NEW.source_id::text, USER);
    END IF;

    IF (((OLD.bud_id IS NULL) AND (NEW.bud_id IS NOT NULL)) OR ((OLD.bud_id IS NOT NULL) AND (NEW.bud_id IS NULL)) OR (OLD.bud_id != NEW.bud_id)) THEN
       PERFORM nex.insertupdatelog('PHENOTYPE'::text, 'BUD_ID'::text, OLD.phenotype_id, OLD.bud_id::text, NEW.bud_id::text, USER);
    END IF;

    IF (OLD.observable_id != NEW.observable_id) THEN
       PERFORM nex.insertupdatelog('PHENOTYPE'::text, 'OBSERVABLE_ID'::text, OLD.phenotype_id, OLD.observable_id::text, NEW.observable_id::text, USER);
    END IF;

    IF (((OLD.qualifier_id IS NULL) AND (NEW.qualifier_id IS NOT NULL)) OR ((OLD.qualifier_id IS NOT NULL) AND (NEW.qualifier_id IS NULL)) OR (OLD.qualifier_id != NEW.qualifier_id)) THEN
       PERFORM nex.insertupdatelog('PHENOTYPE'::text, 'QUALIFIER_ID'::text, OLD.phenotype_id, OLD.qualifier_id::text, NEW.qualifier_id::text, USER);
    END IF;

    IF (((OLD.description IS NULL) AND (NEW.description IS NOT NULL)) OR ((OLD.description IS NOT NULL) AND (NEW.description IS NULL)) OR (OLD.description != NEW.description)) THEN
       PERFORM nex.insertupdatelog('PHENOTYPE'::text, 'DESCRIPTION'::text, OLD.phenotype_id, OLD.description, NEW.description, USER);
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.phenotype_id || '[:]' || OLD.format_name || '[:]' ||
             OLD.display_name || '[:]' || OLD.obj_url || '[:]' ||
             OLD.source_id || '[:]' || coalesce(OLD.bud_id,0) || '[:]' ||
             OLD.observable_id || '[:]' || coalesce(OLD.qualifier_id,0) || '[:]' ||
             coalesce(OLD.description,'') || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

          PERFORM nex.insertdeletelog('PHENOTYPE'::text, OLD.phenotype_id, v_row, USER);

     RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER phenotype_audr
AFTER UPDATE OR DELETE ON nex.phenotype FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_phenotype_audr();

DROP TRIGGER IF EXISTS phenotype_biur ON nex.phenotype CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_phenotype_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       PERFORM nex.checkphenotype(NEW.observable_id, 'observable');

       IF (NEW.qualifier_id is NOT NULL) THEN
	    PERFORM nex.checkphenotype(NEW.qualifier_id, 'qualifier');
        END IF;

       NEW.created_by := UPPER(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;

  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.phenotype_id != OLD.phenotype_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    PERFORM nex.checkphenotype(NEW.observable_id, 'observable');

    IF (NEW.qualifier_id is NOT NULL) THEN
        PERFORM nex.checkphenotype(NEW.qualifier_id, 'qualifier');
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER phenotype_biur
BEFORE INSERT OR UPDATE ON nex.phenotype FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_phenotype_biur();


DROP TRIGGER IF EXISTS proteindomain_audr ON nex.proteindomain CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_proteindomain_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

    IF (OLD.format_name != NEW.format_name) THEN
       PERFORM nex.insertupdatelog('PROTEINDOMAIN'::text, 'FORMAT_NAME'::text, OLD.proteindomain_id, OLD.format_name, NEW.format_name, USER);
    END IF;

    IF (OLD.display_name != NEW.display_name) THEN
       PERFORM nex.insertupdatelog('PROTEINDOMAIN'::text, 'DISPLAY_NAME'::text, OLD.proteindomain_id, OLD.display_name, NEW.display_name, USER);
    END IF;

    IF (OLD.obj_url != NEW.obj_url) THEN
       PERFORM nex.insertupdatelog('PROTEINDOMAIN'::text, 'OBJ_URL'::text, OLD.proteindomain_id, OLD.obj_url, NEW.obj_url, USER);
    END IF;

     IF (OLD.source_id != NEW.source_id) THEN
       PERFORM nex.insertupdatelog('PROTEINDOMAIN'::text, 'SOURCE_ID'::text, OLD.proteindomain_id, OLD.source_id::text, NEW.source_id::text, USER);
    END IF;

    IF (((OLD.interpro_id IS NULL) AND (NEW.interpro_id IS NOT NULL)) OR ((OLD.interpro_id IS NOT NULL) AND (NEW.interpro_id IS NULL)) OR (OLD.interpro_id != NEW.interpro_id)) THEN
       PERFORM nex.insertupdatelog('PROTEINDOMAIN'::text, 'INTERPRO_ID'::text, OLD.proteindomain_id, OLD.interpro_id, NEW.interpro_id, USER);
    END IF;

    IF (((OLD.description IS NULL) AND (NEW.description IS NOT NULL)) OR ((OLD.description IS NOT NULL) AND (NEW.description IS NULL)) OR (OLD.description != NEW.description)) THEN
       PERFORM nex.insertupdatelog('PROTEINDOMAIN'::text, 'DESCRIPTION'::text, OLD.proteindomain_id, OLD.description, NEW.description, USER);
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.proteindomain_id || '[:]' || OLD.format_name || '[:]' ||
             OLD.display_name || '[:]' || OLD.obj_url || '[:]' ||
             OLD.source_id || '[:]' || 
             coalesce(OLD.interpro_id,0) || '[:]' || coalesce(OLD.description,'') || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

        PERFORM nex.insertdeletelog('PROTEINDOMAIN'::text, OLD.proteindomain_id, v_row, USER);

     RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER proteindomain_audr
AFTER UPDATE OR DELETE ON nex.proteindomain FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_proteindomain_audr();

DROP TRIGGER IF EXISTS proteindomain_biur ON nex.proteindomain CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_proteindomain_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := UPPER(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;

  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.proteindomain_id != OLD.proteindomain_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER proteindomain_biur
BEFORE INSERT OR UPDATE ON nex.proteindomain FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_proteindomain_biur();

DROP TRIGGER IF EXISTS proteindomainurl_audr ON nex.proteindomain_url CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_proteindomainurl_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

     IF (OLD.display_name != NEW.display_name) THEN
       PERFORM nex.insertupdatelog('PROTEINDOMAIN_URL'::text, 'DISPLAY_NAME'::text, OLD.url_id, OLD.display_name, NEW.display_name, USER);
    END IF;

    IF (OLD.obj_url != NEW.obj_url) THEN
       PERFORM nex.insertupdatelog('PROTEINDOMAIN_URL'::text, 'OBJ_URL'::text, OLD.url_id, OLD.obj_url, NEW.obj_url, USER);
    END IF;

     IF (OLD.source_id != NEW.source_id) THEN
       PERFORM nex.insertupdatelog('PROTEINDOMAIN_URL'::text, 'SOURCE_ID'::text, OLD.url_id, OLD.source_id::text, NEW.source_id::text, USER);
    END IF;

    IF (OLD.proteindomain_id != NEW.proteindomain_id) THEN
       PERFORM nex.insertupdatelog('PROTEINDOMAIN_URL'::text, 'PROTEINDOMAIN_ID'::text, OLD.url_id, OLD.proteindomain_id::text, NEW.proteindomain_id::text, USER);
    END IF;

    IF (OLD.url_type != NEW.url_type) THEN
       PERFORM nex.insertupdatelog('PROTEINDOMAIN_URL'::text, 'URL_TYPE'::text, OLD.url_id, OLD.url_type, NEW.url_type, USER);
    END IF;

    RETURN NEW;
    
  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.url_id || '[:]' || OLD.display_name || '[:]' ||
             OLD.obj_url || '[:]' || OLD.source_id || '[:]' || 
             OLD.proteindomain_id || '[:]' || OLD.url_type || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

           PERFORM nex.insertdeletelog('PROTEINDOMAIN_URL'::text, OLD.url_id, v_row, USER);

     RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER proteindomainurl_audr
AFTER UPDATE OR DELETE ON nex.proteindomain_url FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_proteindomainurl_audr();

DROP TRIGGER IF EXISTS proteindomainurl_biur ON nex.proteindomain_url CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_proteindomainurl_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := UPPER(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;

  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.url_id != OLD.url_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER proteindomainurl_biur
BEFORE INSERT OR UPDATE ON nex.proteindomain_url FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_proteindomainurl_biur();


DROP TRIGGER IF EXISTS reporter_audr ON nex.reporter CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_reporter_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

    IF (OLD.format_name != NEW.format_name) THEN
       PERFORM nex.insertupdatelog('REPORTER'::text, 'FORMAT_NAME'::text, OLD.reporter_id, OLD.format_name, NEW.format_name, USER);
    END IF;

    IF (OLD.display_name != NEW.display_name) THEN
       PERFORM nex.insertupdatelog('REPORTER'::text, 'DISPLAY_NAME'::text, OLD.reporter_id, OLD.display_name, NEW.display_name, USER);
    END IF;

    IF (OLD.obj_url != NEW.obj_url) THEN
       PERFORM nex.insertupdatelog('REPORTER'::text, 'OBJ_URL'::text, OLD.reporter_id, OLD.obj_url, NEW.obj_url, USER);
    END IF;

     IF (OLD.source_id != NEW.source_id) THEN
       PERFORM nex.insertupdatelog('REPORTER'::text, 'SOURCE_ID'::text, OLD.reporter_id, OLD.source_id::text, NEW.source_id::text, USER);
    END IF;

    IF (((OLD.bud_id IS NULL) AND (NEW.bud_id IS NOT NULL)) OR ((OLD.bud_id IS NOT NULL) AND (NEW.bud_id IS NULL)) OR (OLD.bud_id != NEW.bud_id)) THEN
       PERFORM nex.insertupdatelog('REPORTER'::text, 'BUD_ID'::text, OLD.reporter_id, OLD.bud_id::text, NEW.bud_id::text, USER);
    END IF;

    IF (((OLD.description IS NULL) AND (NEW.description IS NOT NULL)) OR ((OLD.description IS NOT NULL) AND (NEW.description IS NULL)) OR (OLD.description != NEW.description)) THEN
       PERFORM nex.insertupdatelog('REPORTER'::text, 'DESCRIPTION'::text, OLD.reporter_id, OLD.description, NEW.description, USER);
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.reporter_id || '[:]' || OLD.format_name || '[:]' ||
             OLD.display_name || '[:]' || OLD.obj_url || '[:]' ||
             OLD.source_id || '[:]' || coalesce(OLD.bud_id,0) || '[:]' ||
             coalesce(OLD.description,'') || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

          PERFORM nex.insertdeletelog('REPORTER'::text, OLD.reporter_id, v_row, USER);

     RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER reporter_audr
AFTER UPDATE OR DELETE ON nex.reporter FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_reporter_audr();

DROP TRIGGER IF EXISTS reporter_biur ON nex.reporter CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_reporter_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := UPPER(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;

  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.reporter_id != OLD.reporter_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER reporter_biur
BEFORE INSERT OR UPDATE ON nex.reporter FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_reporter_biur();


DROP TRIGGER IF EXISTS reservedname_audr ON nex.reservedname CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_reservedname_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

    IF (OLD.format_name != NEW.format_name) THEN
       PERFORM nex.insertupdatelog('RESERVEDNAME'::text, 'FORMAT_NAME'::text, OLD.reservedname_id, OLD.format_name, NEW.format_name, USER);
    END IF;

     IF (OLD.display_name != NEW.display_name) THEN
       PERFORM nex.insertupdatelog('RESERVEDNAME'::text, 'DISPLAY_NAME'::text, OLD.reservedname_id, OLD.display_name, NEW.display_name, USER);
    END IF;

    IF (OLD.obj_url != NEW.obj_url) THEN
       PERFORM nex.insertupdatelog('RESERVEDNAME'::text, 'OBJ_URL'::text, OLD.reservedname_id, OLD.obj_url, NEW.obj_url, USER);
    END IF;

     IF (OLD.source_id != NEW.source_id) THEN
       PERFORM nex.insertupdatelog('RESERVEDNAME'::text, 'SOURCE_ID'::text, OLD.reservedname_id, OLD.source_id::text, NEW.source_id::text, USER);
    END IF;

    IF (((OLD.bud_id IS NULL) AND (NEW.bud_id IS NOT NULL)) OR ((OLD.bud_id IS NOT NULL) AND (NEW.bud_id IS NULL)) OR (OLD.bud_id != NEW.bud_id)) THEN
       PERFORM nex.insertupdatelog('RESERVEDNAME'::text, 'BUD_ID'::text, OLD.reservedname_id, OLD.bud_id::text, NEW.bud_id::text, USER);
    END IF;

    IF (((OLD.locus_id IS NULL) AND (NEW.locus_id IS NOT NULL)) OR ((OLD.locus_id IS NOT NULL) AND (NEW.locus_id IS NULL)) OR (OLD.locus_id != NEW.locus_id)) THEN
       PERFORM nex.insertupdatelog('RESERVEDNAME'::text, 'LOCUS_ID'::text, OLD.reservedname_id, OLD.locus_id::text, NEW.locus_id::text, USER);
    END IF;

    IF (((OLD.reference_id IS NULL) AND (NEW.reference_id IS NOT NULL)) OR ((OLD.reference_id IS NOT NULL) AND (NEW.reference_id IS NULL)) OR (OLD.reference_id != NEW.reference_id)) THEN
       PERFORM nex.insertupdatelog('RESERVEDNAME'::text, 'REFERENCE_ID'::text, OLD.reservedname_id, OLD.reference_id::text, NEW.reference_id::text, USER);
    END IF;

    IF (OLD.colleague_id != NEW.colleague_id) THEN
       PERFORM nex.insertupdatelog('RESERVEDNAME'::text, 'COLLEAGUE_ID'::text, OLD.reservedname_id, OLD.colleague_id::text, NEW.colleague_id::text, USER);
    END IF;

    IF (OLD.reservation_date != NEW.reservation_date) THEN
       PERFORM nex.insertupdatelog('RESERVEDNAME'::text, 'RESERVATION_DATE'::text, OLD.reservedname_id, OLD.reservation_date::text, NEW.reservation_date::text, USER);
    END IF;

    IF (OLD.expiration_date != NEW.expiration_date) THEN
       PERFORM nex.insertupdatelog('RESERVEDNAME'::text, 'EXPIRATION_DATE'::text, OLD.reservedname_id, OLD.expiration_date::text, NEW.expiration_date::text, USER);
    END IF;

    IF (((OLD.description IS NULL) AND (NEW.description IS NOT NULL)) OR ((OLD.description IS NOT NULL) AND (NEW.description IS NULL)) OR (OLD.description != NEW.description)) THEN
       PERFORM nex.insertupdatelog('RESERVEDNAME'::text, 'DESCRIPTION'::text, OLD.reservedname_id, OLD.description, NEW.description, USER);
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.reservedname_id || '[:]' || OLD.format_name || '[:]' ||
             OLD.display_name || '[:]' || OLD.obj_url || '[:]' ||
             OLD.source_id || '[:]' || coalesce(OLD.bud_id,0) || '[:]' ||
             coalesce(OLD.locus_id,0) || '[:]' || coalesce(OLD.reference_id,0) || '[:]' ||
             OLD.colleague_id || '[:]' || OLD.reservation_date || '[:]' ||
             OLD.expiration_date || '[:]' || coalesce(OLD.description,'') || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

          PERFORM nex.insertdeletelog('RESERVEDNAME'::text, OLD.reservedname_id, v_row, USER);

     RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER reservedname_audr
AFTER UPDATE OR DELETE ON nex.reservedname FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_reservedname_audr();

DROP TRIGGER IF EXISTS reservedname_biur ON nex.reservedname CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_reservedname_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := UPPER(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;
       
  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.reservedname_id != OLD.reservedname_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER reservedname_biur
BEFORE INSERT OR UPDATE ON nex.reservedname FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_reservedname_biur();
